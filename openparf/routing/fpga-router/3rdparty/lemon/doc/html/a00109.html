<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>CostScaling&lt; GR, V, C, TR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00573.html">lemon</a></li><li class="navelem"><a class="el" href="a00109.html">CostScaling</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="a00732.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">CostScaling&lt; GR, V, C, TR &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00612.html">Minimum Cost Flow Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GR, typename V, typename C, typename TR&gt;<br/>
class lemon::CostScaling&lt; GR, V, C, TR &gt;</h3>

<p><a class="el" href="a00109.html">CostScaling</a> implements a cost scaling algorithm that performs push/augment and relabel operations for finding a <a class="el" href="a00010.html">minimum cost flow</a> <a class="el" href="a00638.html#CITEREF_amo93networkflows">[1]</a>, <a class="el" href="a00638.html#CITEREF_goldberg90approximation">[17]</a>, <a class="el" href="a00638.html#CITEREF_goldberg97efficient">[18]</a>, <a class="el" href="a00638.html#CITEREF_bunnagel98efficient">[2]</a>. It is a highly efficient primal-dual solution method, which can be viewed as the generalization of the <a class="el" href="a00311.html">preflow push-relabel</a> algorithm for the maximum flow problem. It is a polynomial algorithm, its running time complexity is <img class="formulaInl" alt="$O(n^2m\log(nK))$" src="form_61.png"/>, where <em>K</em> denotes the maximum arc cost.</p>
<p>In general, <a class="el" href="a00276.html">NetworkSimplex</a> and <a class="el" href="a00109.html">CostScaling</a> are the fastest implementations available in LEMON for solving this problem. (For more information, see <a class="el" href="a00612.html">the module page</a>.)</p>
<p>Most of the parameters of the problem (except for the digraph) can be given using separate functions, and the algorithm can be executed using the <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> function. If some parameters are not specified, then default values will be used.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GR</td><td>The digraph type the algorithm runs on. </td></tr>
    <tr><td class="paramname">V</td><td>The number type used for flow amounts, capacity bounds and supply values in the algorithm. By default, it is <code>int</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The number type used for costs and potentials in the algorithm. By default, it is the same as <code>V</code>. </td></tr>
    <tr><td class="paramname">TR</td><td>The traits class that defines various types used by the algorithm. By default, it is <a class="el" href="a00110.html">CostScalingDefaultTraits&lt;GR, V, C&gt;</a>. In most cases, this parameter should not be set directly, consider to use the named template parameters instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Both <code>V</code> and <code>C</code> must be signed number types. </dd>
<dd>
All input data (capacities, supply values, and costs) must be integer. </dd>
<dd>
This algorithm does not support negative costs for arcs having infinite upper bound.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>CostScaling provides three different internal methods, from which the most efficient one is used by default. For more information, see <a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a>. </dd></dl>
</div>
<p><code>#include &lt;lemon/cost_scaling.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00361.html">SetLargeCost</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00012.html#named-templ-param">Named parameter</a> for setting <code>LargeCost</code> type.  <a href="a00361.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4c669cb1cb4d98dfea944e9ceec7d33e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a> { <a class="el" href="a00109.html#a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483">INFEASIBLE</a>, 
<a class="el" href="a00109.html#a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad">OPTIMAL</a>, 
<a class="el" href="a00109.html#a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef">UNBOUNDED</a>
 }</td></tr>
<tr class="memdesc:a4c669cb1cb4d98dfea944e9ceec7d33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem type constants for the <code><a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e" title="Run the algorithm. ">run()</a></code> function.  <a href="a00109.html#a4c669cb1cb4d98dfea944e9ceec7d33e">More...</a><br/></td></tr>
<tr class="separator:a4c669cb1cb4d98dfea944e9ceec7d33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3c0067e44c5ef3210a256d06c16b0f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a> { <a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0fad263caec619c4d99e4684ba0fabd9493">PUSH</a>, 
<a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0facd2e1aa2398886ced14024f626167b10">AUGMENT</a>, 
<a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0fad4476e3f57a85ac799fa83de6730c665">PARTIAL_AUGMENT</a>
 }</td></tr>
<tr class="memdesc:a2a3c0067e44c5ef3210a256d06c16b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants for selecting the internal method.  <a href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0f">More...</a><br/></td></tr>
<tr class="separator:a2a3c0067e44c5ef3210a256d06c16b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750f38b47fd56ef715849c3bd77fbe77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a750f38b47fd56ef715849c3bd77fbe77"></a>
typedef TR::Digraph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a750f38b47fd56ef715849c3bd77fbe77">Digraph</a></td></tr>
<tr class="memdesc:a750f38b47fd56ef715849c3bd77fbe77"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the digraph. <br/></td></tr>
<tr class="separator:a750f38b47fd56ef715849c3bd77fbe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2042899ede28a8f6f0fdceb92a7d3c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2042899ede28a8f6f0fdceb92a7d3c2"></a>
typedef TR::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a></td></tr>
<tr class="memdesc:aa2042899ede28a8f6f0fdceb92a7d3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the flow amounts, capacity bounds and supply values. <br/></td></tr>
<tr class="separator:aa2042899ede28a8f6f0fdceb92a7d3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9142822eba184f2778b6aac70b0900b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9142822eba184f2778b6aac70b0900b3"></a>
typedef TR::Cost&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a9142822eba184f2778b6aac70b0900b3">Cost</a></td></tr>
<tr class="memdesc:a9142822eba184f2778b6aac70b0900b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the arc costs. <br/></td></tr>
<tr class="separator:a9142822eba184f2778b6aac70b0900b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f34159326618acfb683317c3df26662"><td class="memItemLeft" align="right" valign="top">typedef TR::LargeCost&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a7f34159326618acfb683317c3df26662">LargeCost</a></td></tr>
<tr class="memdesc:a7f34159326618acfb683317c3df26662"><td class="mdescLeft">&#160;</td><td class="mdescRight">The large cost type.  <a href="#a7f34159326618acfb683317c3df26662">More...</a><br/></td></tr>
<tr class="separator:a7f34159326618acfb683317c3df26662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab157e5452122f7a7f73dfda5ed931d69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab157e5452122f7a7f73dfda5ed931d69"></a>
typedef TR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#ab157e5452122f7a7f73dfda5ed931d69">Traits</a></td></tr>
<tr class="memdesc:ab157e5452122f7a7f73dfda5ed931d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a00110.html">traits class</a> of the algorithm. <br/></td></tr>
<tr class="separator:ab157e5452122f7a7f73dfda5ed931d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aef36da2d5f6a91d3c945078c91a00f29"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#aef36da2d5f6a91d3c945078c91a00f29">CostScaling</a> (const GR &amp;graph)</td></tr>
<tr class="memdesc:aef36da2d5f6a91d3c945078c91a00f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#aef36da2d5f6a91d3c945078c91a00f29">More...</a><br/></td></tr>
<tr class="separator:aef36da2d5f6a91d3c945078c91a00f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parameters</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The parameters of the algorithm can be specified using these functions. </p>
</div></td></tr>
<tr class="memitem:a73716786403308acf826049db4fcae5a"><td class="memTemplParams" colspan="2">template&lt;typename LowerMap &gt; </td></tr>
<tr class="memitem:a73716786403308acf826049db4fcae5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00109.html">CostScaling</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00109.html#a73716786403308acf826049db4fcae5a">lowerMap</a> (const LowerMap &amp;map)</td></tr>
<tr class="memdesc:a73716786403308acf826049db4fcae5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the lower bounds on the arcs.  <a href="#a73716786403308acf826049db4fcae5a">More...</a><br/></td></tr>
<tr class="separator:a73716786403308acf826049db4fcae5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba20715de6a3fe3a93086f59bd41b1f"><td class="memTemplParams" colspan="2">template&lt;typename UpperMap &gt; </td></tr>
<tr class="memitem:a2ba20715de6a3fe3a93086f59bd41b1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00109.html">CostScaling</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00109.html#a2ba20715de6a3fe3a93086f59bd41b1f">upperMap</a> (const UpperMap &amp;map)</td></tr>
<tr class="memdesc:a2ba20715de6a3fe3a93086f59bd41b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the upper bounds (capacities) on the arcs.  <a href="#a2ba20715de6a3fe3a93086f59bd41b1f">More...</a><br/></td></tr>
<tr class="separator:a2ba20715de6a3fe3a93086f59bd41b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3289d8da25c7c41bf2019e219a207c57"><td class="memTemplParams" colspan="2">template&lt;typename CostMap &gt; </td></tr>
<tr class="memitem:a3289d8da25c7c41bf2019e219a207c57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00109.html">CostScaling</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00109.html#a3289d8da25c7c41bf2019e219a207c57">costMap</a> (const CostMap &amp;map)</td></tr>
<tr class="memdesc:a3289d8da25c7c41bf2019e219a207c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the costs of the arcs.  <a href="#a3289d8da25c7c41bf2019e219a207c57">More...</a><br/></td></tr>
<tr class="separator:a3289d8da25c7c41bf2019e219a207c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed44b74b82792e31be304ec0b84dfad"><td class="memTemplParams" colspan="2">template&lt;typename SupplyMap &gt; </td></tr>
<tr class="memitem:aaed44b74b82792e31be304ec0b84dfad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00109.html">CostScaling</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00109.html#aaed44b74b82792e31be304ec0b84dfad">supplyMap</a> (const SupplyMap &amp;map)</td></tr>
<tr class="memdesc:aaed44b74b82792e31be304ec0b84dfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the supply values of the nodes.  <a href="#aaed44b74b82792e31be304ec0b84dfad">More...</a><br/></td></tr>
<tr class="separator:aaed44b74b82792e31be304ec0b84dfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606e5cc8a41acd2f6f0998c096e79a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00109.html">CostScaling</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a606e5cc8a41acd2f6f0998c096e79a0d">stSupply</a> (const Node &amp;s, const Node &amp;t, <a class="el" href="a00109.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> k)</td></tr>
<tr class="memdesc:a606e5cc8a41acd2f6f0998c096e79a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set single source and target nodes and a supply value.  <a href="#a606e5cc8a41acd2f6f0998c096e79a0d">More...</a><br/></td></tr>
<tr class="separator:a606e5cc8a41acd2f6f0998c096e79a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The algorithm can be executed using <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a>. </p>
</div></td></tr>
<tr class="memitem:a1f864136a21e6ad70a82f14d6560ee7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00109.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run</a> (<a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a> method=<a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0fad4476e3f57a85ac799fa83de6730c665">PARTIAL_AUGMENT</a>, int factor=16)</td></tr>
<tr class="memdesc:a1f864136a21e6ad70a82f14d6560ee7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the algorithm.  <a href="#a1f864136a21e6ad70a82f14d6560ee7e">More...</a><br/></td></tr>
<tr class="separator:a1f864136a21e6ad70a82f14d6560ee7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da4b33bee24846e97c4fad32696d7b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00109.html">CostScaling</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a3da4b33bee24846e97c4fad32696d7b2">resetParams</a> ()</td></tr>
<tr class="memdesc:a3da4b33bee24846e97c4fad32696d7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all the parameters that have been given before.  <a href="#a3da4b33bee24846e97c4fad32696d7b2">More...</a><br/></td></tr>
<tr class="separator:a3da4b33bee24846e97c4fad32696d7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec24c3696fc3c1818effd0523dffa452"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00109.html">CostScaling</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#aec24c3696fc3c1818effd0523dffa452">reset</a> ()</td></tr>
<tr class="memdesc:aec24c3696fc3c1818effd0523dffa452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal data structures and all the parameters that have been given before.  <a href="#aec24c3696fc3c1818effd0523dffa452">More...</a><br/></td></tr>
<tr class="separator:aec24c3696fc3c1818effd0523dffa452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The results of the algorithm can be obtained using these functions.<br/>
The <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> function must be called before using them. </p>
</div></td></tr>
<tr class="memitem:a4e1efd04a6b234645d1ca18d2635d57e"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a4e1efd04a6b234645d1ca18d2635d57e"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00109.html#a4e1efd04a6b234645d1ca18d2635d57e">totalCost</a> () const </td></tr>
<tr class="memdesc:a4e1efd04a6b234645d1ca18d2635d57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total cost of the found flow.  <a href="#a4e1efd04a6b234645d1ca18d2635d57e">More...</a><br/></td></tr>
<tr class="separator:a4e1efd04a6b234645d1ca18d2635d57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc53c0667fdfb95dadd6a302f045941"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00109.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a7fc53c0667fdfb95dadd6a302f045941">flow</a> (const Arc &amp;a) const </td></tr>
<tr class="memdesc:a7fc53c0667fdfb95dadd6a302f045941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the flow on the given arc.  <a href="#a7fc53c0667fdfb95dadd6a302f045941">More...</a><br/></td></tr>
<tr class="separator:a7fc53c0667fdfb95dadd6a302f045941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fb0010590a95a23fda72ce45474a2a"><td class="memTemplParams" colspan="2">template&lt;typename FlowMap &gt; </td></tr>
<tr class="memitem:ac7fb0010590a95a23fda72ce45474a2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00109.html#ac7fb0010590a95a23fda72ce45474a2a">flowMap</a> (FlowMap &amp;map) const </td></tr>
<tr class="memdesc:ac7fb0010590a95a23fda72ce45474a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the flow values (the primal solution) into the given map.  <a href="#ac7fb0010590a95a23fda72ce45474a2a">More...</a><br/></td></tr>
<tr class="separator:ac7fb0010590a95a23fda72ce45474a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97efaa2b500bb002f116bf4ba7c9b0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00109.html#a9142822eba184f2778b6aac70b0900b3">Cost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#ac97efaa2b500bb002f116bf4ba7c9b0b">potential</a> (const Node &amp;n) const </td></tr>
<tr class="memdesc:ac97efaa2b500bb002f116bf4ba7c9b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the potential (dual value) of the given node.  <a href="#ac97efaa2b500bb002f116bf4ba7c9b0b">More...</a><br/></td></tr>
<tr class="separator:ac97efaa2b500bb002f116bf4ba7c9b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeeff1d0249ffae4db8cc516b77d2cc9"><td class="memTemplParams" colspan="2">template&lt;typename PotentialMap &gt; </td></tr>
<tr class="memitem:afeeff1d0249ffae4db8cc516b77d2cc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00109.html#afeeff1d0249ffae4db8cc516b77d2cc9">potentialMap</a> (PotentialMap &amp;map) const </td></tr>
<tr class="memdesc:afeeff1d0249ffae4db8cc516b77d2cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the potential values (the dual solution) into the given map.  <a href="#afeeff1d0249ffae4db8cc516b77d2cc9">More...</a><br/></td></tr>
<tr class="separator:afeeff1d0249ffae4db8cc516b77d2cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a601ffd79f13610daacadd46f973507c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00109.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a601ffd79f13610daacadd46f973507c5">INF</a></td></tr>
<tr class="memdesc:a601ffd79f13610daacadd46f973507c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant for infinite upper bounds (capacities).  <a href="#a601ffd79f13610daacadd46f973507c5">More...</a><br/></td></tr>
<tr class="separator:a601ffd79f13610daacadd46f973507c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5f0ba940293922c1175f599af9b5490e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f0ba940293922c1175f599af9b5490e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a5f0ba940293922c1175f599af9b5490e">startAugment</a> (int max_length)</td></tr>
<tr class="memdesc:a5f0ba940293922c1175f599af9b5490e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the algorithm performing augment and relabel operations. <br/></td></tr>
<tr class="separator:a5f0ba940293922c1175f599af9b5490e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8a4c20a6226e471b185f33b68eadb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d8a4c20a6226e471b185f33b68eadb1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html#a0d8a4c20a6226e471b185f33b68eadb1">startPush</a> ()</td></tr>
<tr class="memdesc:a0d8a4c20a6226e471b185f33b68eadb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the algorithm performing push and relabel operations. <br/></td></tr>
<tr class="separator:a0d8a4c20a6226e471b185f33b68eadb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a7f34159326618acfb683317c3df26662"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef TR::LargeCost <a class="el" href="a00109.html#a7f34159326618acfb683317c3df26662">LargeCost</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The large cost type used for internal computations. By default, it is <code>long</code> <code>long</code> if the <code>Cost</code> type is integer, otherwise it is <code>double</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00109.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum type containing the problem type constants that can be returned by the <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> function of the algorithm. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483"></a>INFEASIBLE</em>&nbsp;</td><td class="fielddoc">
<p>The problem has no feasible solution (flow). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad"></a>OPTIMAL</em>&nbsp;</td><td class="fielddoc">
<p>The problem has optimal solution (i.e. it is feasible and bounded), and the algorithm has found optimal flow and node potentials (primal and dual solutions). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef"></a>UNBOUNDED</em>&nbsp;</td><td class="fielddoc">
<p>The digraph contains an arc of negative cost and infinite upper bound. It means that the objective function is unbounded on that arc, however, note that it could actually be bounded over the feasible flows, but this algroithm cannot handle these cases. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a2a3c0067e44c5ef3210a256d06c16b0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum type containing constants for selecting the internal method for the <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> function.</p>
<p><a class="el" href="a00109.html">CostScaling</a> provides three internal methods that differ mainly in their base operations, which are used in conjunction with the relabel operation. By default, the so called <a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0fad4476e3f57a85ac799fa83de6730c665">Partial Augment-Relabel</a> method is used, which turned out to be the most efficient and the most robust on various test inputs. However, the other methods can be selected using the <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> function with the proper parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a2a3c0067e44c5ef3210a256d06c16b0fad263caec619c4d99e4684ba0fabd9493"></a>PUSH</em>&nbsp;</td><td class="fielddoc">
<p>Local push operations are used, i.e. flow is moved only on one admissible arc at once. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2a3c0067e44c5ef3210a256d06c16b0facd2e1aa2398886ced14024f626167b10"></a>AUGMENT</em>&nbsp;</td><td class="fielddoc">
<p>Augment operations are used, i.e. flow is moved on admissible paths from a node with excess to a node with deficit. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a2a3c0067e44c5ef3210a256d06c16b0fad4476e3f57a85ac799fa83de6730c665"></a>PARTIAL_AUGMENT</em>&nbsp;</td><td class="fielddoc">
<p>Partial augment operations are used, i.e. flow is moved on admissible paths started from a node with excess, but the lengths of these paths are limited. This method can be viewed as a combined version of the previous two operations. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aef36da2d5f6a91d3c945078c91a00f29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html">CostScaling</a> </td>
          <td>(</td>
          <td class="paramtype">const GR &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The constructor of the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The digraph the algorithm runs on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a73716786403308acf826049db4fcae5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html">CostScaling</a>&amp; lowerMap </td>
          <td>(</td>
          <td class="paramtype">const LowerMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the lower bounds on the arcs. If it is not used before calling <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a>, the lower bounds will be set to zero on all arcs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>An arc map storing the lower bounds. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a2ba20715de6a3fe3a93086f59bd41b1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html">CostScaling</a>&amp; upperMap </td>
          <td>(</td>
          <td class="paramtype">const UpperMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the upper bounds (capacities) on the arcs. If it is not used before calling <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a>, the upper bounds will be set to <a class="el" href="a00109.html#a601ffd79f13610daacadd46f973507c5">INF</a> on all arcs (i.e. the flow value will be unbounded from above).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>An arc map storing the upper bounds. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a3289d8da25c7c41bf2019e219a207c57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html">CostScaling</a>&amp; costMap </td>
          <td>(</td>
          <td class="paramtype">const CostMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the costs of the arcs. If it is not used before calling <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a>, the costs will be set to <code>1</code> on all arcs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>An arc map storing the costs. Its <code>Value</code> type must be convertible to the <code>Cost</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="aaed44b74b82792e31be304ec0b84dfad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html">CostScaling</a>&amp; supplyMap </td>
          <td>(</td>
          <td class="paramtype">const SupplyMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the supply values of the nodes. If neither this function nor <a class="el" href="a00109.html#a606e5cc8a41acd2f6f0998c096e79a0d">stSupply()</a> is used before calling <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a>, the supply of each node will be set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A node map storing the supply values. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a606e5cc8a41acd2f6f0998c096e79a0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html">CostScaling</a>&amp; stSupply </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Node &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00109.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets a single source node and a single target node and the required flow value. If neither this function nor <a class="el" href="a00109.html#aaed44b74b82792e31be304ec0b84dfad">supplyMap()</a> is used before calling <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a>, the supply of each node will be set to zero.</p>
<p>Using this function has the same effect as using <a class="el" href="a00109.html#aaed44b74b82792e31be304ec0b84dfad">supplyMap()</a> with a map in which <code>k</code> is assigned to <code>s</code>, <code>-k</code> is assigned to <code>t</code> and all other nodes have zero supply value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source node. </td></tr>
    <tr><td class="paramname">t</td><td>The target node. </td></tr>
    <tr><td class="paramname">k</td><td>The required amount of flow from node <code>s</code> to node <code>t</code> (i.e. the supply of <code>s</code> and the demand of <code>t</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a1f864136a21e6ad70a82f14d6560ee7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a> run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0fad4476e3f57a85ac799fa83de6730c665">PARTIAL_AUGMENT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>factor</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function runs the algorithm. The paramters can be specified using functions <a class="el" href="a00109.html#a73716786403308acf826049db4fcae5a">lowerMap()</a>, <a class="el" href="a00109.html#a2ba20715de6a3fe3a93086f59bd41b1f">upperMap()</a>, <a class="el" href="a00109.html#a3289d8da25c7c41bf2019e219a207c57">costMap()</a>, <a class="el" href="a00109.html#aaed44b74b82792e31be304ec0b84dfad">supplyMap()</a>, <a class="el" href="a00109.html#a606e5cc8a41acd2f6f0998c096e79a0d">stSupply()</a>. For example, </p>
<div class="fragment"><div class="line">*    CostScaling&lt;ListDigraph&gt; cs(graph);</div>
<div class="line">*    cs.lowerMap(lower).upperMap(upper).costMap(cost)</div>
<div class="line">*      .supplyMap(sup).run();</div>
<div class="line">*  </div>
</div><!-- fragment --><p>This function can be called more than once. All the given parameters are kept for the next call, unless <a class="el" href="a00109.html#a3da4b33bee24846e97c4fad32696d7b2">resetParams()</a> or <a class="el" href="a00109.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> is used, thus only the modified parameters have to be set again. If the underlying digraph was also modified after the construction of the class (or the last <a class="el" href="a00109.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> call), then the <a class="el" href="a00109.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> function must be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">method</td><td>The internal method that will be used in the algorithm. For more information, see <a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0f">Method</a>. </td></tr>
    <tr><td class="paramname">factor</td><td>The cost scaling factor. It must be at least two.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>INFEASIBLE</code> if no feasible flow exists, <br/>
 <code>OPTIMAL</code> if the problem has optimal solution (i.e. it is feasible and bounded), and the algorithm has found optimal flow and node potentials (primal and dual solutions), <br/>
 <code>UNBOUNDED</code> if the digraph contains an arc of negative cost and infinite upper bound. It means that the objective function is unbounded on that arc, however, note that it could actually be bounded over the feasible flows, but this algroithm cannot handle these cases.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00109.html#a4c669cb1cb4d98dfea944e9ceec7d33e" title="Problem type constants for the run() function. ">ProblemType</a>, <a class="el" href="a00109.html#a2a3c0067e44c5ef3210a256d06c16b0f" title="Constants for selecting the internal method. ">Method</a> </dd>
<dd>
<a class="el" href="a00109.html#a3da4b33bee24846e97c4fad32696d7b2" title="Reset all the parameters that have been given before. ">resetParams()</a>, <a class="el" href="a00109.html#aec24c3696fc3c1818effd0523dffa452" title="Reset the internal data structures and all the parameters that have been given before. ">reset()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3da4b33bee24846e97c4fad32696d7b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html">CostScaling</a>&amp; resetParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function resets all the paramaters that have been given before using functions <a class="el" href="a00109.html#a73716786403308acf826049db4fcae5a">lowerMap()</a>, <a class="el" href="a00109.html#a2ba20715de6a3fe3a93086f59bd41b1f">upperMap()</a>, <a class="el" href="a00109.html#a3289d8da25c7c41bf2019e219a207c57">costMap()</a>, <a class="el" href="a00109.html#aaed44b74b82792e31be304ec0b84dfad">supplyMap()</a>, <a class="el" href="a00109.html#a606e5cc8a41acd2f6f0998c096e79a0d">stSupply()</a>.</p>
<p>It is useful for multiple <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> calls. Basically, all the given parameters are kept for the next <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> call, unless <a class="el" href="a00109.html#a3da4b33bee24846e97c4fad32696d7b2">resetParams()</a> or <a class="el" href="a00109.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> is used. If the underlying digraph was also modified after the construction of the class or the last <a class="el" href="a00109.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> call, then the <a class="el" href="a00109.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> function must be used, otherwise <a class="el" href="a00109.html#a3da4b33bee24846e97c4fad32696d7b2">resetParams()</a> is sufficient.</p>
<p>For example, </p>
<div class="fragment"><div class="line">*    CostScaling&lt;ListDigraph&gt; cs(graph);</div>
<div class="line">* </div>
<div class="line">*    <span class="comment">// First run</span></div>
<div class="line">*    cs.lowerMap(lower).upperMap(upper).costMap(cost)</div>
<div class="line">*      .supplyMap(sup).run();</div>
<div class="line">* </div>
<div class="line">*    <span class="comment">// Run again with modified cost map (resetParams() is not called,</span></div>
<div class="line">*    <span class="comment">// so only the cost map have to be set again)</span></div>
<div class="line">*    cost[e] += 100;</div>
<div class="line">*    cs.costMap(cost).run();</div>
<div class="line">* </div>
<div class="line">*    <span class="comment">// Run again from scratch using resetParams()</span></div>
<div class="line">*    <span class="comment">// (the lower bounds will be set to zero on all arcs)</span></div>
<div class="line">*    cs.resetParams();</div>
<div class="line">*    cs.upperMap(capacity).costMap(cost)</div>
<div class="line">*      .supplyMap(sup).run();</div>
<div class="line">*  </div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>(*this)</code></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00109.html#aec24c3696fc3c1818effd0523dffa452" title="Reset the internal data structures and all the parameters that have been given before. ">reset()</a>, <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e" title="Run the algorithm. ">run()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aec24c3696fc3c1818effd0523dffa452"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html">CostScaling</a>&amp; reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function resets the internal data structures and all the paramaters that have been given before using functions <a class="el" href="a00109.html#a73716786403308acf826049db4fcae5a">lowerMap()</a>, <a class="el" href="a00109.html#a2ba20715de6a3fe3a93086f59bd41b1f">upperMap()</a>, <a class="el" href="a00109.html#a3289d8da25c7c41bf2019e219a207c57">costMap()</a>, <a class="el" href="a00109.html#aaed44b74b82792e31be304ec0b84dfad">supplyMap()</a>, <a class="el" href="a00109.html#a606e5cc8a41acd2f6f0998c096e79a0d">stSupply()</a>.</p>
<p>It is useful for multiple <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> calls. By default, all the given parameters are kept for the next <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> call, unless <a class="el" href="a00109.html#a3da4b33bee24846e97c4fad32696d7b2">resetParams()</a> or <a class="el" href="a00109.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> is used. If the underlying digraph was also modified after the construction of the class or the last <a class="el" href="a00109.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> call, then the <a class="el" href="a00109.html#aec24c3696fc3c1818effd0523dffa452">reset()</a> function must be used, otherwise <a class="el" href="a00109.html#a3da4b33bee24846e97c4fad32696d7b2">resetParams()</a> is sufficient.</p>
<p>See <a class="el" href="a00109.html#a3da4b33bee24846e97c4fad32696d7b2">resetParams()</a> for examples.</p>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00109.html#a3da4b33bee24846e97c4fad32696d7b2" title="Reset all the parameters that have been given before. ">resetParams()</a>, <a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e" title="Run the algorithm. ">run()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4e1efd04a6b234645d1ca18d2635d57e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number totalCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the total cost of the found flow. Its complexity is O(m).</p>
<dl class="section note"><dt>Note</dt><dd>The return type of the function can be specified as a template parameter. For example, <div class="fragment"><div class="line">*    cs.totalCost&lt;<span class="keywordtype">double</span>&gt;();</div>
<div class="line">*  </div>
</div><!-- fragment --> It is useful if the total cost cannot be stored in the <code>Cost</code> type of the algorithm, which is the default return type of the function.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fc53c0667fdfb95dadd6a302f045941"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> flow </td>
          <td>(</td>
          <td class="paramtype">const Arc &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the flow on the given arc.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7fb0010590a95a23fda72ce45474a2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flowMap </td>
          <td>(</td>
          <td class="paramtype">FlowMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies the flow value on each arc into the given map. The <code>Value</code> type of the algorithm must be convertible to the <code>Value</code> type of the map.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ac97efaa2b500bb002f116bf4ba7c9b0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00109.html#a9142822eba184f2778b6aac70b0900b3">Cost</a> potential </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the potential (dual value) of the given node.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="afeeff1d0249ffae4db8cc516b77d2cc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void potentialMap </td>
          <td>(</td>
          <td class="paramtype">PotentialMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies the potential (dual value) of each node into the given map. The <code>Cost</code> type of the algorithm must be convertible to the <code>Value</code> type of the map.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00109.html#a1f864136a21e6ad70a82f14d6560ee7e">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a601ffd79f13610daacadd46f973507c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00109.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> INF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constant for infinite upper bounds (capacities). It is <code>std::numeric_limits&lt;Value&gt;::infinity()</code> if available, <code>std::numeric_limits&lt;Value&gt;::max()</code> otherwise. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 7 2014 16:39:52 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
