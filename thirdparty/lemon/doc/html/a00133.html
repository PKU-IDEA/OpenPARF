<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Dijkstra&lt; GR, LEN, TR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00573.html">lemon</a></li><li class="navelem"><a class="el" href="a00133.html">Dijkstra</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="a00772.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Dijkstra&lt; GR, LEN, TR &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00609.html">Shortest Path Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GR, typename LEN, typename TR&gt;<br/>
class lemon::Dijkstra&lt; GR, LEN, TR &gt;</h3>

<p>This class provides an efficient implementation of the Dijkstra algorithm.</p>
<p>The Dijkstra algorithm solves the single-source shortest path problem when all arc lengths are non-negative. If there are negative lengths, the <a class="el" href="a00045.html" title="BellmanFord algorithm class. ">BellmanFord</a> algorithm should be used instead.</p>
<p>The arc lengths are passed to the algorithm using a <a class="el" href="a00319.html">ReadMap</a>, so it is easy to change it to any kind of length. The type of the length is determined by the <a class="el" href="a00319.html#a34b57a974fe67a997b7693e6e71cd904">Value</a> of the length map. It is also possible to change the underlying priority heap.</p>
<p>There is also a <a class="el" href="a00609.html#gaa781be76e5adb6a9df7592457a5c3857">function-type interface</a> for the Dijkstra algorithm, which is convenient in the simplier cases and it can be used easier.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GR</td><td>The type of the digraph the algorithm runs on. The default type is <a class="el" href="a00242.html">ListDigraph</a>. </td></tr>
    <tr><td class="paramname">LEN</td><td>A <a class="el" href="a00319.html">readable</a> arc map that specifies the lengths of the arcs. It is read once for each arc, so the map may involve in relatively time consuming process to compute the arc lengths if it is necessary. The default map type is <a class="el" href="a00036.html">GR::ArcMap&lt;int&gt;</a>. </td></tr>
    <tr><td class="paramname">TR</td><td>The traits class that defines various types used by the algorithm. By default, it is <a class="el" href="a00135.html">DijkstraDefaultTraits&lt;GR, LEN&gt;</a>. In most cases, this parameter should not be set directly, consider to use the named template parameters instead. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;lemon/dijkstra.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00345.html">SetDistMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00012.html#named-templ-param">Named parameter</a> for setting <code>DistMap</code> type.  <a href="a00345.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00356.html">SetHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00012.html#named-templ-param">Named parameter</a> for setting heap and cross reference types  <a href="a00356.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00365.html">SetOperationTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00012.html#named-templ-param">Named parameter</a> for setting <code>OperationTraits</code> type  <a href="a00365.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00372.html">SetPredMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00012.html#named-templ-param">Named parameter</a> for setting <code>PredMap</code> type.  <a href="a00372.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00378.html">SetProcessedMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00012.html#named-templ-param">Named parameter</a> for setting <code>ProcessedMap</code> type.  <a href="a00378.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00388.html">SetStandardHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00012.html#named-templ-param">Named parameter</a> for setting heap and cross reference types with automatic allocation  <a href="a00388.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00391.html">SetStandardProcessedMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00012.html#named-templ-param">Named parameter</a> for setting <code>ProcessedMap</code> type to be <code>Digraph::NodeMap&lt;bool&gt;</code>.  <a href="a00391.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a750f38b47fd56ef715849c3bd77fbe77"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a750f38b47fd56ef715849c3bd77fbe77"></a>
typedef TR::Digraph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a750f38b47fd56ef715849c3bd77fbe77">Digraph</a></td></tr>
<tr class="memdesc:a750f38b47fd56ef715849c3bd77fbe77"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the digraph the algorithm runs on. <br/></td></tr>
<tr class="separator:a750f38b47fd56ef715849c3bd77fbe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2042899ede28a8f6f0fdceb92a7d3c2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2042899ede28a8f6f0fdceb92a7d3c2"></a>
typedef TR::Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a></td></tr>
<tr class="memdesc:aa2042899ede28a8f6f0fdceb92a7d3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the arc lengths. <br/></td></tr>
<tr class="separator:aa2042899ede28a8f6f0fdceb92a7d3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1094a242a4e9be216f0623b0a7381c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1094a242a4e9be216f0623b0a7381c0"></a>
typedef TR::LengthMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#ac1094a242a4e9be216f0623b0a7381c0">LengthMap</a></td></tr>
<tr class="memdesc:ac1094a242a4e9be216f0623b0a7381c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the map that stores the arc lengths. <br/></td></tr>
<tr class="separator:ac1094a242a4e9be216f0623b0a7381c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9638061e7acac70160feb0ea49c29c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc9638061e7acac70160feb0ea49c29c"></a>
typedef TR::PredMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#adc9638061e7acac70160feb0ea49c29c">PredMap</a></td></tr>
<tr class="memdesc:adc9638061e7acac70160feb0ea49c29c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the map that stores the predecessor arcs of the shortest paths. <br/></td></tr>
<tr class="separator:adc9638061e7acac70160feb0ea49c29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d9c2819f215994ded26fbe42e2fd26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6d9c2819f215994ded26fbe42e2fd26"></a>
typedef TR::DistMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#ad6d9c2819f215994ded26fbe42e2fd26">DistMap</a></td></tr>
<tr class="memdesc:ad6d9c2819f215994ded26fbe42e2fd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the map that stores the distances of the nodes. <br/></td></tr>
<tr class="separator:ad6d9c2819f215994ded26fbe42e2fd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e332c55acc2c5cb99d35ff40accab1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43e332c55acc2c5cb99d35ff40accab1"></a>
typedef TR::ProcessedMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a43e332c55acc2c5cb99d35ff40accab1">ProcessedMap</a></td></tr>
<tr class="memdesc:a43e332c55acc2c5cb99d35ff40accab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the map that indicates which nodes are processed. <br/></td></tr>
<tr class="separator:a43e332c55acc2c5cb99d35ff40accab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7ae5a0651af9c9cfadd1462718979d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4d7ae5a0651af9c9cfadd1462718979d"></a>
typedef PredMapPath&lt; <a class="el" href="a00133.html#a750f38b47fd56ef715849c3bd77fbe77">Digraph</a>, <br class="typebreak"/>
<a class="el" href="a00133.html#adc9638061e7acac70160feb0ea49c29c">PredMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a4d7ae5a0651af9c9cfadd1462718979d">Path</a></td></tr>
<tr class="memdesc:a4d7ae5a0651af9c9cfadd1462718979d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the paths. <br/></td></tr>
<tr class="separator:a4d7ae5a0651af9c9cfadd1462718979d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc498f33875179555a71ba9441c400a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dc498f33875179555a71ba9441c400a"></a>
typedef TR::HeapCrossRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a0dc498f33875179555a71ba9441c400a">HeapCrossRef</a></td></tr>
<tr class="memdesc:a0dc498f33875179555a71ba9441c400a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cross reference type used for the current heap. <br/></td></tr>
<tr class="separator:a0dc498f33875179555a71ba9441c400a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e3f1c47cd4bffb15e3bbc452585f7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1e3f1c47cd4bffb15e3bbc452585f7c"></a>
typedef TR::Heap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#ab1e3f1c47cd4bffb15e3bbc452585f7c">Heap</a></td></tr>
<tr class="memdesc:ab1e3f1c47cd4bffb15e3bbc452585f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The heap type used by the algorithm. <br/></td></tr>
<tr class="separator:ab1e3f1c47cd4bffb15e3bbc452585f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda95bfb086e37f03cb0be4ba8725f47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afda95bfb086e37f03cb0be4ba8725f47"></a>
typedef TR::OperationTraits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#afda95bfb086e37f03cb0be4ba8725f47">OperationTraits</a></td></tr>
<tr class="memdesc:afda95bfb086e37f03cb0be4ba8725f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a00134.html">operation traits class</a> of the algorithm. <br/></td></tr>
<tr class="separator:afda95bfb086e37f03cb0be4ba8725f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab157e5452122f7a7f73dfda5ed931d69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab157e5452122f7a7f73dfda5ed931d69"></a>
typedef TR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#ab157e5452122f7a7f73dfda5ed931d69">Traits</a></td></tr>
<tr class="memdesc:ab157e5452122f7a7f73dfda5ed931d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a00135.html">traits class</a> of the algorithm. <br/></td></tr>
<tr class="separator:ab157e5452122f7a7f73dfda5ed931d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a58fc0895a271a1aa712f66aaf3425b12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a58fc0895a271a1aa712f66aaf3425b12">Dijkstra</a> (const <a class="el" href="a00133.html#a750f38b47fd56ef715849c3bd77fbe77">Digraph</a> &amp;g, const <a class="el" href="a00133.html#ac1094a242a4e9be216f0623b0a7381c0">LengthMap</a> &amp;length)</td></tr>
<tr class="memdesc:a58fc0895a271a1aa712f66aaf3425b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a58fc0895a271a1aa712f66aaf3425b12">More...</a><br/></td></tr>
<tr class="separator:a58fc0895a271a1aa712f66aaf3425b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2cad16e6cb57cad22fe766c9e809ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f2cad16e6cb57cad22fe766c9e809ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a9f2cad16e6cb57cad22fe766c9e809ca">~Dijkstra</a> ()</td></tr>
<tr class="memdesc:a9f2cad16e6cb57cad22fe766c9e809ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a9f2cad16e6cb57cad22fe766c9e809ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca1fc5a2484f8284b37ac8b98a6de89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00133.html">Dijkstra</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#acca1fc5a2484f8284b37ac8b98a6de89">lengthMap</a> (const <a class="el" href="a00133.html#ac1094a242a4e9be216f0623b0a7381c0">LengthMap</a> &amp;m)</td></tr>
<tr class="memdesc:acca1fc5a2484f8284b37ac8b98a6de89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the length map.  <a href="#acca1fc5a2484f8284b37ac8b98a6de89">More...</a><br/></td></tr>
<tr class="separator:acca1fc5a2484f8284b37ac8b98a6de89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553990801b3f933961ad14abfee00c0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00133.html">Dijkstra</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a553990801b3f933961ad14abfee00c0e">predMap</a> (<a class="el" href="a00133.html#adc9638061e7acac70160feb0ea49c29c">PredMap</a> &amp;m)</td></tr>
<tr class="memdesc:a553990801b3f933961ad14abfee00c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the map that stores the predecessor arcs.  <a href="#a553990801b3f933961ad14abfee00c0e">More...</a><br/></td></tr>
<tr class="separator:a553990801b3f933961ad14abfee00c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f543d7d3c4b2ab9ecdef5d14f90269d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00133.html">Dijkstra</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a6f543d7d3c4b2ab9ecdef5d14f90269d">processedMap</a> (<a class="el" href="a00133.html#a43e332c55acc2c5cb99d35ff40accab1">ProcessedMap</a> &amp;m)</td></tr>
<tr class="memdesc:a6f543d7d3c4b2ab9ecdef5d14f90269d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the map that indicates which nodes are processed.  <a href="#a6f543d7d3c4b2ab9ecdef5d14f90269d">More...</a><br/></td></tr>
<tr class="separator:a6f543d7d3c4b2ab9ecdef5d14f90269d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344715cda707dac050bf32c85923f651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00133.html">Dijkstra</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a344715cda707dac050bf32c85923f651">distMap</a> (<a class="el" href="a00133.html#ad6d9c2819f215994ded26fbe42e2fd26">DistMap</a> &amp;m)</td></tr>
<tr class="memdesc:a344715cda707dac050bf32c85923f651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the map that stores the distances of the nodes.  <a href="#a344715cda707dac050bf32c85923f651">More...</a><br/></td></tr>
<tr class="separator:a344715cda707dac050bf32c85923f651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0403be9c030237c46a9ab320f5bfbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00133.html">Dijkstra</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a7a0403be9c030237c46a9ab320f5bfbe">heap</a> (<a class="el" href="a00133.html#ab1e3f1c47cd4bffb15e3bbc452585f7c">Heap</a> &amp;hp, <a class="el" href="a00133.html#a0dc498f33875179555a71ba9441c400a">HeapCrossRef</a> &amp;cr)</td></tr>
<tr class="memdesc:a7a0403be9c030237c46a9ab320f5bfbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the heap and the cross reference used by algorithm.  <a href="#a7a0403be9c030237c46a9ab320f5bfbe">More...</a><br/></td></tr>
<tr class="separator:a7a0403be9c030237c46a9ab320f5bfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution Control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The simplest way to execute the Dijkstra algorithm is to use one of the member functions called <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a>.<br/>
If you need better control on the execution, you have to call <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> first, then you can add several source nodes with <a class="el" href="a00133.html#acf3cbe74733e4534c1cebb8383974bae">addSource()</a>. Finally the actual path computation can be performed with one of the <a class="el" href="a00133.html#a60de64d75454385b23995437f1d72669">start()</a> functions. </p>
</div></td></tr>
<tr class="memitem:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr class="memdesc:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the internal data structures.  <a href="#a02fd73d861ef2e4aabb38c0c9ff82947">More...</a><br/></td></tr>
<tr class="separator:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3cbe74733e4534c1cebb8383974bae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#acf3cbe74733e4534c1cebb8383974bae">addSource</a> (Node s, <a class="el" href="a00133.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> dst=OperationTraits::zero())</td></tr>
<tr class="memdesc:acf3cbe74733e4534c1cebb8383974bae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new source node.  <a href="#acf3cbe74733e4534c1cebb8383974bae">More...</a><br/></td></tr>
<tr class="separator:acf3cbe74733e4534c1cebb8383974bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba758047d7378b8a06320d29ce170d7"><td class="memItemLeft" align="right" valign="top">Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#adba758047d7378b8a06320d29ce170d7">processNextNode</a> ()</td></tr>
<tr class="memdesc:adba758047d7378b8a06320d29ce170d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes the next node in the priority heap.  <a href="#adba758047d7378b8a06320d29ce170d7">More...</a><br/></td></tr>
<tr class="separator:adba758047d7378b8a06320d29ce170d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca98e3b1fef1a4508df143a24b73b046"><td class="memItemLeft" align="right" valign="top">Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#aca98e3b1fef1a4508df143a24b73b046">nextNode</a> () const </td></tr>
<tr class="memdesc:aca98e3b1fef1a4508df143a24b73b046"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next node to be processed.  <a href="#aca98e3b1fef1a4508df143a24b73b046">More...</a><br/></td></tr>
<tr class="separator:aca98e3b1fef1a4508df143a24b73b046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dcd2be02feaff0a95c21824e805445"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#ab6dcd2be02feaff0a95c21824e805445">emptyQueue</a> () const </td></tr>
<tr class="memdesc:ab6dcd2be02feaff0a95c21824e805445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>false</code> if there are nodes to be processed.  <a href="#ab6dcd2be02feaff0a95c21824e805445">More...</a><br/></td></tr>
<tr class="separator:ab6dcd2be02feaff0a95c21824e805445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942d30059e28f60ba6dd1944ab8e416e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a942d30059e28f60ba6dd1944ab8e416e">queueSize</a> () const </td></tr>
<tr class="memdesc:a942d30059e28f60ba6dd1944ab8e416e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the nodes to be processed.  <a href="#a942d30059e28f60ba6dd1944ab8e416e">More...</a><br/></td></tr>
<tr class="separator:a942d30059e28f60ba6dd1944ab8e416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60de64d75454385b23995437f1d72669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a60de64d75454385b23995437f1d72669">start</a> ()</td></tr>
<tr class="memdesc:a60de64d75454385b23995437f1d72669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the algorithm.  <a href="#a60de64d75454385b23995437f1d72669">More...</a><br/></td></tr>
<tr class="separator:a60de64d75454385b23995437f1d72669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8de9dfc16e4b3cb6b38733e82f6449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a8b8de9dfc16e4b3cb6b38733e82f6449">start</a> (Node t)</td></tr>
<tr class="memdesc:a8b8de9dfc16e4b3cb6b38733e82f6449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the algorithm until the given target node is processed.  <a href="#a8b8de9dfc16e4b3cb6b38733e82f6449">More...</a><br/></td></tr>
<tr class="separator:a8b8de9dfc16e4b3cb6b38733e82f6449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9ccb55c64065301a4e11f13e4d05fb"><td class="memTemplParams" colspan="2">template&lt;class NodeBoolMap &gt; </td></tr>
<tr class="memitem:acf9ccb55c64065301a4e11f13e4d05fb"><td class="memTemplItemLeft" align="right" valign="top">Node&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00133.html#acf9ccb55c64065301a4e11f13e4d05fb">start</a> (const NodeBoolMap &amp;nm)</td></tr>
<tr class="memdesc:acf9ccb55c64065301a4e11f13e4d05fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the algorithm until a condition is met.  <a href="#acf9ccb55c64065301a4e11f13e4d05fb">More...</a><br/></td></tr>
<tr class="separator:acf9ccb55c64065301a4e11f13e4d05fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f0682c90a4e8a23c259943e899402e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run</a> (Node s)</td></tr>
<tr class="memdesc:ae3f0682c90a4e8a23c259943e899402e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the algorithm from the given source node.  <a href="#ae3f0682c90a4e8a23c259943e899402e">More...</a><br/></td></tr>
<tr class="separator:ae3f0682c90a4e8a23c259943e899402e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c3c4217c98b58a8618397d65d400c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#ad2c3c4217c98b58a8618397d65d400c8">run</a> (Node s, Node t)</td></tr>
<tr class="memdesc:ad2c3c4217c98b58a8618397d65d400c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the shortest path between <code>s</code> and <code>t</code>.  <a href="#ad2c3c4217c98b58a8618397d65d400c8">More...</a><br/></td></tr>
<tr class="separator:ad2c3c4217c98b58a8618397d65d400c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The results of the Dijkstra algorithm can be obtained using these functions.<br/>
Either <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> should be called before using them. </p>
</div></td></tr>
<tr class="memitem:a6a33507c667ac2bddd240d0baff1a573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00133.html#a4d7ae5a0651af9c9cfadd1462718979d">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a6a33507c667ac2bddd240d0baff1a573">path</a> (Node t) const </td></tr>
<tr class="memdesc:a6a33507c667ac2bddd240d0baff1a573"><td class="mdescLeft">&#160;</td><td class="mdescRight">The shortest path to the given node.  <a href="#a6a33507c667ac2bddd240d0baff1a573">More...</a><br/></td></tr>
<tr class="separator:a6a33507c667ac2bddd240d0baff1a573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a41051a602b0a9134d128cf1f409f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00133.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a70a41051a602b0a9134d128cf1f409f6">dist</a> (Node v) const </td></tr>
<tr class="memdesc:a70a41051a602b0a9134d128cf1f409f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The distance of the given node from the root(s).  <a href="#a70a41051a602b0a9134d128cf1f409f6">More...</a><br/></td></tr>
<tr class="separator:a70a41051a602b0a9134d128cf1f409f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fdbb84b58bd3f5daedde027070e056"><td class="memItemLeft" align="right" valign="top">Arc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#af9fdbb84b58bd3f5daedde027070e056">predArc</a> (Node v) const </td></tr>
<tr class="memdesc:af9fdbb84b58bd3f5daedde027070e056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'previous arc' of the shortest path tree for the given node.  <a href="#af9fdbb84b58bd3f5daedde027070e056">More...</a><br/></td></tr>
<tr class="separator:af9fdbb84b58bd3f5daedde027070e056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bd1c535e3d4fcb9c58afbb54ac47e1"><td class="memItemLeft" align="right" valign="top">Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a89bd1c535e3d4fcb9c58afbb54ac47e1">predNode</a> (Node v) const </td></tr>
<tr class="memdesc:a89bd1c535e3d4fcb9c58afbb54ac47e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 'previous node' of the shortest path tree for the given node.  <a href="#a89bd1c535e3d4fcb9c58afbb54ac47e1">More...</a><br/></td></tr>
<tr class="separator:a89bd1c535e3d4fcb9c58afbb54ac47e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77feee7321863f24b67813c0ef8dc5c0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00133.html#ad6d9c2819f215994ded26fbe42e2fd26">DistMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a77feee7321863f24b67813c0ef8dc5c0">distMap</a> () const </td></tr>
<tr class="memdesc:a77feee7321863f24b67813c0ef8dc5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the node map that stores the distances of the nodes.  <a href="#a77feee7321863f24b67813c0ef8dc5c0">More...</a><br/></td></tr>
<tr class="separator:a77feee7321863f24b67813c0ef8dc5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec5920cc073b88c4c5f6c46a8f4aa4b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00133.html#adc9638061e7acac70160feb0ea49c29c">PredMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#aeec5920cc073b88c4c5f6c46a8f4aa4b">predMap</a> () const </td></tr>
<tr class="memdesc:aeec5920cc073b88c4c5f6c46a8f4aa4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const reference to the node map that stores the predecessor arcs.  <a href="#aeec5920cc073b88c4c5f6c46a8f4aa4b">More...</a><br/></td></tr>
<tr class="separator:aeec5920cc073b88c4c5f6c46a8f4aa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb98c427556a2afe917e41fe8d3e75bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#abb98c427556a2afe917e41fe8d3e75bf">reached</a> (Node v) const </td></tr>
<tr class="memdesc:abb98c427556a2afe917e41fe8d3e75bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given node is reached from the root(s).  <a href="#abb98c427556a2afe917e41fe8d3e75bf">More...</a><br/></td></tr>
<tr class="separator:abb98c427556a2afe917e41fe8d3e75bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376f9f86c0b6bf5fbcf5ee8d76f4cc7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a376f9f86c0b6bf5fbcf5ee8d76f4cc7a">processed</a> (Node v) const </td></tr>
<tr class="memdesc:a376f9f86c0b6bf5fbcf5ee8d76f4cc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a node is processed.  <a href="#a376f9f86c0b6bf5fbcf5ee8d76f4cc7a">More...</a><br/></td></tr>
<tr class="separator:a376f9f86c0b6bf5fbcf5ee8d76f4cc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514b1faa39e460ebc8e00c90d839f3cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00133.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html#a514b1faa39e460ebc8e00c90d839f3cf">currentDist</a> (Node v) const </td></tr>
<tr class="memdesc:a514b1faa39e460ebc8e00c90d839f3cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current distance of the given node from the root(s).  <a href="#a514b1faa39e460ebc8e00c90d839f3cf">More...</a><br/></td></tr>
<tr class="separator:a514b1faa39e460ebc8e00c90d839f3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a58fc0895a271a1aa712f66aaf3425b12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00133.html">Dijkstra</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00133.html#a750f38b47fd56ef715849c3bd77fbe77">Digraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00133.html#ac1094a242a4e9be216f0623b0a7381c0">LengthMap</a> &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>The digraph the algorithm runs on. </td></tr>
    <tr><td class="paramname">length</td><td>The length map used by the algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acca1fc5a2484f8284b37ac8b98a6de89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00133.html">Dijkstra</a>&amp; lengthMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00133.html#ac1094a242a4e9be216f0623b0a7381c0">LengthMap</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the length map. </p>
<dl class="section return"><dt>Returns</dt><dd><code> (*this) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="a553990801b3f933961ad14abfee00c0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00133.html">Dijkstra</a>&amp; predMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00133.html#adc9638061e7acac70160feb0ea49c29c">PredMap</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the map that stores the predecessor arcs. If you don't use this function before calling <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a>, an instance will be allocated automatically. The destructor deallocates this automatically allocated map, of course. </p>
<dl class="section return"><dt>Returns</dt><dd><code> (*this) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="a6f543d7d3c4b2ab9ecdef5d14f90269d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00133.html">Dijkstra</a>&amp; processedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00133.html#a43e332c55acc2c5cb99d35ff40accab1">ProcessedMap</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the map that indicates which nodes are processed. If you don't use this function before calling <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a>, an instance will be allocated automatically. The destructor deallocates this automatically allocated map, of course. </p>
<dl class="section return"><dt>Returns</dt><dd><code> (*this) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="a344715cda707dac050bf32c85923f651"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00133.html">Dijkstra</a>&amp; distMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00133.html#ad6d9c2819f215994ded26fbe42e2fd26">DistMap</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the map that stores the distances of the nodes calculated by the algorithm. If you don't use this function before calling <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a>, an instance will be allocated automatically. The destructor deallocates this automatically allocated map, of course. </p>
<dl class="section return"><dt>Returns</dt><dd><code> (*this) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a0403be9c030237c46a9ab320f5bfbe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00133.html">Dijkstra</a>&amp; heap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00133.html#ab1e3f1c47cd4bffb15e3bbc452585f7c">Heap</a> &amp;&#160;</td>
          <td class="paramname"><em>hp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00133.html#a0dc498f33875179555a71ba9441c400a">HeapCrossRef</a> &amp;&#160;</td>
          <td class="paramname"><em>cr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the heap and the cross reference used by algorithm. If you don't use this function before calling <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a>, heap and cross reference instances will be allocated automatically. The destructor deallocates these automatically allocated objects, of course. </p>
<dl class="section return"><dt>Returns</dt><dd><code> (*this) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="a02fd73d861ef2e4aabb38c0c9ff82947"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the internal data structures. </p>

</div>
</div>
<a class="anchor" id="acf3cbe74733e4534c1cebb8383974bae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addSource </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00133.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a>&#160;</td>
          <td class="paramname"><em>dst</em> = <code>OperationTraits::zero()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a new source node to the priority heap. The optional second parameter is the initial distance of the node.</p>
<p>The function checks if the node has already been added to the heap and it is pushed to the heap only if either it was not in the heap or the shortest path found till then is shorter than <code>dst</code>. </p>

</div>
</div>
<a class="anchor" id="adba758047d7378b8a06320d29ce170d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node processNextNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Processes the next node in the priority heap.</p>
<dl class="section return"><dt>Returns</dt><dd>The processed node.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The priority heap must not be empty. </dd></dl>

</div>
</div>
<a class="anchor" id="aca98e3b1fef1a4508df143a24b73b046"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node nextNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the next node to be processed or <code>INVALID</code> if the priority heap is empty. </p>

</div>
</div>
<a class="anchor" id="ab6dcd2be02feaff0a95c21824e805445"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool emptyQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>false</code> if there are nodes to be processed in the priority heap. </p>

</div>
</div>
<a class="anchor" id="a942d30059e28f60ba6dd1944ab8e416e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int queueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of the nodes to be processed in the priority heap. </p>

</div>
</div>
<a class="anchor" id="a60de64d75454385b23995437f1d72669"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes the algorithm.</p>
<p>This method runs the Dijkstra algorithm from the root node(s) in order to compute the shortest path to each node.</p>
<p>The algorithm computes</p>
<ul>
<li>the shortest path tree (forest),</li>
<li>the distance of each node from the root(s).</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="Initializes the internal data structures. ">init()</a> must be called and at least one root node should be added with <a class="el" href="a00133.html#acf3cbe74733e4534c1cebb8383974bae" title="Adds a new source node. ">addSource()</a> before using this function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>d.start()</code> is just a shortcut of the following code. <div class="fragment"><div class="line">*   <span class="keywordflow">while</span> ( !d.emptyQueue() ) {</div>
<div class="line">*     d.processNextNode();</div>
<div class="line">*   }</div>
<div class="line">* </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b8de9dfc16e4b3cb6b38733e82f6449"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void start </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes the algorithm until the given target node is processed.</p>
<p>This method runs the Dijkstra algorithm from the root node(s) in order to compute the shortest path to <code>t</code>.</p>
<p>The algorithm computes</p>
<ul>
<li>the shortest path to <code>t</code>,</li>
<li>the distance of <code>t</code> from the root(s).</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="Initializes the internal data structures. ">init()</a> must be called and at least one root node should be added with <a class="el" href="a00133.html#acf3cbe74733e4534c1cebb8383974bae" title="Adds a new source node. ">addSource()</a> before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="acf9ccb55c64065301a4e11f13e4d05fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node start </td>
          <td>(</td>
          <td class="paramtype">const NodeBoolMap &amp;&#160;</td>
          <td class="paramname"><em>nm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes the algorithm until a condition is met.</p>
<p>This method runs the Dijkstra algorithm from the root node(s) in order to compute the shortest path to a node <code>v</code> with <code>nm[v]</code> true, if such a node can be found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>A <code>bool</code> (or convertible) node map. The algorithm will stop when it reaches a node <code>v</code> with <code>nm[v]</code> true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reached node <code>v</code> with <code>nm[v]</code> true or <code>INVALID</code> if no such node was found.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="Initializes the internal data structures. ">init()</a> must be called and at least one root node should be added with <a class="el" href="a00133.html#acf3cbe74733e4534c1cebb8383974bae" title="Adds a new source node. ">addSource()</a> before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3f0682c90a4e8a23c259943e899402e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method runs the Dijkstra algorithm from node <code>s</code> in order to compute the shortest path to each node.</p>
<p>The algorithm computes</p>
<ul>
<li>the shortest path tree,</li>
<li>the distance of each node from the root.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><code>d.run(s)</code> is just a shortcut of the following code. <div class="fragment"><div class="line">*   d.init();</div>
<div class="line">*   d.addSource(s);</div>
<div class="line">*   d.start();</div>
<div class="line">* </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ad2c3c4217c98b58a8618397d65d400c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool run </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method runs the Dijkstra algorithm from node <code>s</code> in order to compute the shortest path to node <code>t</code> (it stops searching when <code>t</code> is processed).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>t</code> is reachable form <code>s</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Apart from the return value, <code>d.run(s,t)</code> is just a shortcut of the following code. <div class="fragment"><div class="line">*   d.init();</div>
<div class="line">*   d.addSource(s);</div>
<div class="line">*   d.start(t);</div>
<div class="line">* </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a6a33507c667ac2bddd240d0baff1a573"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00133.html#a4d7ae5a0651af9c9cfadd1462718979d">Path</a> path </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the shortest path to the given node from the root(s).</p>
<dl class="section warning"><dt>Warning</dt><dd><code>t</code> should be reached from the root(s).</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Either <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a70a41051a602b0a9134d128cf1f409f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00133.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> dist </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the distance of the given node from the root(s).</p>
<dl class="section warning"><dt>Warning</dt><dd>If node <code>v</code> is not reached from the root(s), then the return value of this function is undefined.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Either <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="af9fdbb84b58bd3f5daedde027070e056"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Arc predArc </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the 'previous arc' of the shortest path tree for the node <code>v</code>, i.e. it returns the last arc of a shortest path from a root to <code>v</code>. It is <code>INVALID</code> if <code>v</code> is not reached from the root(s) or if <code>v</code> is a root.</p>
<p>The shortest path tree used here is equal to the shortest path tree used in <a class="el" href="a00133.html#a89bd1c535e3d4fcb9c58afbb54ac47e1">predNode()</a> and <a class="el" href="a00133.html#a553990801b3f933961ad14abfee00c0e">predMap()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Either <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a89bd1c535e3d4fcb9c58afbb54ac47e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node predNode </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the 'previous node' of the shortest path tree for the node <code>v</code>, i.e. it returns the last but one node of a shortest path from a root to <code>v</code>. It is <code>INVALID</code> if <code>v</code> is not reached from the root(s) or if <code>v</code> is a root.</p>
<p>The shortest path tree used here is equal to the shortest path tree used in <a class="el" href="a00133.html#af9fdbb84b58bd3f5daedde027070e056">predArc()</a> and <a class="el" href="a00133.html#a553990801b3f933961ad14abfee00c0e">predMap()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Either <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a77feee7321863f24b67813c0ef8dc5c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00133.html#ad6d9c2819f215994ded26fbe42e2fd26">DistMap</a>&amp; distMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to the node map that stores the distances of the nodes calculated by the algorithm.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Either <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="aeec5920cc073b88c4c5f6c46a8f4aa4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00133.html#adc9638061e7acac70160feb0ea49c29c">PredMap</a>&amp; predMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to the node map that stores the predecessor arcs, which form the shortest path tree (forest).</p>
<dl class="section pre"><dt>Precondition</dt><dd>Either <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="abb98c427556a2afe917e41fe8d3e75bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reached </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <code>v</code> is reached from the root(s).</p>
<dl class="section pre"><dt>Precondition</dt><dd>Either <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a376f9f86c0b6bf5fbcf5ee8d76f4cc7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool processed </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <code>v</code> is processed, i.e. the shortest path to <code>v</code> has already found.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Either <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a514b1faa39e460ebc8e00c90d839f3cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00133.html#aa2042899ede28a8f6f0fdceb92a7d3c2">Value</a> currentDist </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current distance of the given node from the root(s). It may be decreased in the following processes.</p>
<dl class="section pre"><dt>Precondition</dt><dd>Either <a class="el" href="a00133.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00133.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function and node <code>v</code> must be reached but not necessarily processed. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 7 2014 16:39:53 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
