<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>NetworkSimplex&lt; GR, V, C &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00573.html">lemon</a></li><li class="navelem"><a class="el" href="a00276.html">NetworkSimplex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="a01034.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">NetworkSimplex&lt; GR, V, C &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00612.html">Minimum Cost Flow Algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GR, typename V = int, typename C = V&gt;<br/>
class lemon::NetworkSimplex&lt; GR, V, C &gt;</h3>

<p><a class="el" href="a00276.html">NetworkSimplex</a> implements the primal Network Simplex algorithm for finding a <a class="el" href="a00010.html">minimum cost flow</a> <a class="el" href="a00638.html#CITEREF_amo93networkflows">[1]</a>, <a class="el" href="a00638.html#CITEREF_dantzig63linearprog">[8]</a>, <a class="el" href="a00638.html#CITEREF_kellyoneill91netsimplex">[22]</a>. This algorithm is a highly efficient specialized version of the linear programming simplex method directly for the minimum cost flow problem.</p>
<p>In general, <a class="el" href="a00276.html">NetworkSimplex</a> and <a class="el" href="a00109.html">CostScaling</a> are the fastest implementations available in LEMON for solving this problem. (For more information, see <a class="el" href="a00612.html">the module page</a>.) Furthermore, this class supports both directions of the supply/demand inequality constraints. For more information, see <a class="el" href="a00276.html#ac860a45e09c68fb71f723d392c3161ac">SupplyType</a>.</p>
<p>Most of the parameters of the problem (except for the digraph) can be given using separate functions, and the algorithm can be executed using the <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> function. If some parameters are not specified, then default values will be used.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GR</td><td>The digraph type the algorithm runs on. </td></tr>
    <tr><td class="paramname">V</td><td>The number type used for flow amounts, capacity bounds and supply values in the algorithm. By default, it is <code>int</code>. </td></tr>
    <tr><td class="paramname">C</td><td>The number type used for costs and potentials in the algorithm. By default, it is the same as <code>V</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Both <code>V</code> and <code>C</code> must be signed number types. </dd>
<dd>
All input data (capacities, supply values, and costs) must be integer.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>NetworkSimplex provides five different pivot rule implementations, from which the most efficient one is used by default. For more information, see <a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2">PivotRule</a>. </dd></dl>
</div>
<p><code>#include &lt;lemon/network_simplex.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4c669cb1cb4d98dfea944e9ceec7d33e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a> { <a class="el" href="a00276.html#a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483">INFEASIBLE</a>, 
<a class="el" href="a00276.html#a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad">OPTIMAL</a>, 
<a class="el" href="a00276.html#a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef">UNBOUNDED</a>
 }</td></tr>
<tr class="memdesc:a4c669cb1cb4d98dfea944e9ceec7d33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Problem type constants for the <code><a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53" title="Run the algorithm. ">run()</a></code> function.  <a href="a00276.html#a4c669cb1cb4d98dfea944e9ceec7d33e">More...</a><br/></td></tr>
<tr class="separator:a4c669cb1cb4d98dfea944e9ceec7d33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac860a45e09c68fb71f723d392c3161ac"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#ac860a45e09c68fb71f723d392c3161ac">SupplyType</a> { <a class="el" href="a00276.html#ac860a45e09c68fb71f723d392c3161aca99705e9593e3e5c078150b293c86561e">GEQ</a>, 
<a class="el" href="a00276.html#ac860a45e09c68fb71f723d392c3161aca5eba1d52e68e10fb2dafcb363cec49b7">LEQ</a>
 }</td></tr>
<tr class="memdesc:ac860a45e09c68fb71f723d392c3161ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants for selecting the type of the supply constraints.  <a href="a00276.html#ac860a45e09c68fb71f723d392c3161ac">More...</a><br/></td></tr>
<tr class="separator:ac860a45e09c68fb71f723d392c3161ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310d3a1fcfff1e099330ae372abc73c2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2">PivotRule</a> { <br/>
&#160;&#160;<a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2a7c31211b575a3beecd934538c4419b25">FIRST_ELIGIBLE</a>, 
<a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2ac89b3377964fb28026f9b814f30c210b">BEST_ELIGIBLE</a>, 
<a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2afa32a0f9c82dc3e2e1000b6086d3fc1c">BLOCK_SEARCH</a>, 
<a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2a8d608c7bc486d1c56c7e5a5a6c6a616d">CANDIDATE_LIST</a>, 
<br/>
&#160;&#160;<a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2a76eceb36ac871a19d694999a965f877a">ALTERING_LIST</a>
<br/>
 }</td></tr>
<tr class="memdesc:a310d3a1fcfff1e099330ae372abc73c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants for selecting the pivot rule.  <a href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2">More...</a><br/></td></tr>
<tr class="separator:a310d3a1fcfff1e099330ae372abc73c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1768456283cc436140a9ffae849dd2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c1768456283cc436140a9ffae849dd2"></a>
typedef V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#a6c1768456283cc436140a9ffae849dd2">Value</a></td></tr>
<tr class="memdesc:a6c1768456283cc436140a9ffae849dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the flow amounts, capacity bounds and supply values. <br/></td></tr>
<tr class="separator:a6c1768456283cc436140a9ffae849dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb81a88e6bbaf933ca20ea3bbba7a2c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeb81a88e6bbaf933ca20ea3bbba7a2c"></a>
typedef C&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#adeb81a88e6bbaf933ca20ea3bbba7a2c">Cost</a></td></tr>
<tr class="memdesc:adeb81a88e6bbaf933ca20ea3bbba7a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the arc costs. <br/></td></tr>
<tr class="separator:adeb81a88e6bbaf933ca20ea3bbba7a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aadcbd3709a402a8ba8d06b8c3d6504d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#aadcbd3709a402a8ba8d06b8c3d6504d4">NetworkSimplex</a> (const GR &amp;graph, bool arc_mixing=true)</td></tr>
<tr class="memdesc:aadcbd3709a402a8ba8d06b8c3d6504d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#aadcbd3709a402a8ba8d06b8c3d6504d4">More...</a><br/></td></tr>
<tr class="separator:aadcbd3709a402a8ba8d06b8c3d6504d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parameters</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The parameters of the algorithm can be specified using these functions. </p>
</div></td></tr>
<tr class="memitem:aa0198dc86458cf5d9893eaac3875faff"><td class="memTemplParams" colspan="2">template&lt;typename LowerMap &gt; </td></tr>
<tr class="memitem:aa0198dc86458cf5d9893eaac3875faff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00276.html">NetworkSimplex</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#aa0198dc86458cf5d9893eaac3875faff">lowerMap</a> (const LowerMap &amp;map)</td></tr>
<tr class="memdesc:aa0198dc86458cf5d9893eaac3875faff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the lower bounds on the arcs.  <a href="#aa0198dc86458cf5d9893eaac3875faff">More...</a><br/></td></tr>
<tr class="separator:aa0198dc86458cf5d9893eaac3875faff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d130a8189e0bed5939be2876b1183f1"><td class="memTemplParams" colspan="2">template&lt;typename UpperMap &gt; </td></tr>
<tr class="memitem:a3d130a8189e0bed5939be2876b1183f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00276.html">NetworkSimplex</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#a3d130a8189e0bed5939be2876b1183f1">upperMap</a> (const UpperMap &amp;map)</td></tr>
<tr class="memdesc:a3d130a8189e0bed5939be2876b1183f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the upper bounds (capacities) on the arcs.  <a href="#a3d130a8189e0bed5939be2876b1183f1">More...</a><br/></td></tr>
<tr class="separator:a3d130a8189e0bed5939be2876b1183f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa88624e168f246d882e8193fdf12f5b"><td class="memTemplParams" colspan="2">template&lt;typename CostMap &gt; </td></tr>
<tr class="memitem:afa88624e168f246d882e8193fdf12f5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00276.html">NetworkSimplex</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#afa88624e168f246d882e8193fdf12f5b">costMap</a> (const CostMap &amp;map)</td></tr>
<tr class="memdesc:afa88624e168f246d882e8193fdf12f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the costs of the arcs.  <a href="#afa88624e168f246d882e8193fdf12f5b">More...</a><br/></td></tr>
<tr class="separator:afa88624e168f246d882e8193fdf12f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3856a08752190c4b99f5e006e3b14c53"><td class="memTemplParams" colspan="2">template&lt;typename SupplyMap &gt; </td></tr>
<tr class="memitem:a3856a08752190c4b99f5e006e3b14c53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00276.html">NetworkSimplex</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#a3856a08752190c4b99f5e006e3b14c53">supplyMap</a> (const SupplyMap &amp;map)</td></tr>
<tr class="memdesc:a3856a08752190c4b99f5e006e3b14c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the supply values of the nodes.  <a href="#a3856a08752190c4b99f5e006e3b14c53">More...</a><br/></td></tr>
<tr class="separator:a3856a08752190c4b99f5e006e3b14c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac622127c2be52342b9becb61ff28e56e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00276.html">NetworkSimplex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#ac622127c2be52342b9becb61ff28e56e">stSupply</a> (const Node &amp;s, const Node &amp;t, <a class="el" href="a00276.html#a6c1768456283cc436140a9ffae849dd2">Value</a> k)</td></tr>
<tr class="memdesc:ac622127c2be52342b9becb61ff28e56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set single source and target nodes and a supply value.  <a href="#ac622127c2be52342b9becb61ff28e56e">More...</a><br/></td></tr>
<tr class="separator:ac622127c2be52342b9becb61ff28e56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c06e412dc08e6a541abbcf97385b1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00276.html">NetworkSimplex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#a40c06e412dc08e6a541abbcf97385b1e">supplyType</a> (<a class="el" href="a00276.html#ac860a45e09c68fb71f723d392c3161ac">SupplyType</a> supply_type)</td></tr>
<tr class="memdesc:a40c06e412dc08e6a541abbcf97385b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the type of the supply constraints.  <a href="#a40c06e412dc08e6a541abbcf97385b1e">More...</a><br/></td></tr>
<tr class="separator:a40c06e412dc08e6a541abbcf97385b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution Control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The algorithm can be executed using <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>. </p>
</div></td></tr>
<tr class="memitem:a591276ea8f1afbe9d24bd1c1d48b0f53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00276.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run</a> (<a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2">PivotRule</a> pivot_rule=<a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2afa32a0f9c82dc3e2e1000b6086d3fc1c">BLOCK_SEARCH</a>)</td></tr>
<tr class="memdesc:a591276ea8f1afbe9d24bd1c1d48b0f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the algorithm.  <a href="#a591276ea8f1afbe9d24bd1c1d48b0f53">More...</a><br/></td></tr>
<tr class="separator:a591276ea8f1afbe9d24bd1c1d48b0f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefce8a05d41659d7aaffb4cb47eeec43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00276.html">NetworkSimplex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams</a> ()</td></tr>
<tr class="memdesc:aefce8a05d41659d7aaffb4cb47eeec43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all the parameters that have been given before.  <a href="#aefce8a05d41659d7aaffb4cb47eeec43">More...</a><br/></td></tr>
<tr class="separator:aefce8a05d41659d7aaffb4cb47eeec43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88086127469093e19a9a024bbf60c360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00276.html">NetworkSimplex</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#a88086127469093e19a9a024bbf60c360">reset</a> ()</td></tr>
<tr class="memdesc:a88086127469093e19a9a024bbf60c360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the internal data structures and all the parameters that have been given before.  <a href="#a88086127469093e19a9a024bbf60c360">More...</a><br/></td></tr>
<tr class="separator:a88086127469093e19a9a024bbf60c360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The results of the algorithm can be obtained using these functions.<br/>
The <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> function must be called before using them. </p>
</div></td></tr>
<tr class="memitem:a4e1efd04a6b234645d1ca18d2635d57e"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a4e1efd04a6b234645d1ca18d2635d57e"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#a4e1efd04a6b234645d1ca18d2635d57e">totalCost</a> () const </td></tr>
<tr class="memdesc:a4e1efd04a6b234645d1ca18d2635d57e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total cost of the found flow.  <a href="#a4e1efd04a6b234645d1ca18d2635d57e">More...</a><br/></td></tr>
<tr class="separator:a4e1efd04a6b234645d1ca18d2635d57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc53c0667fdfb95dadd6a302f045941"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00276.html#a6c1768456283cc436140a9ffae849dd2">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#a7fc53c0667fdfb95dadd6a302f045941">flow</a> (const Arc &amp;a) const </td></tr>
<tr class="memdesc:a7fc53c0667fdfb95dadd6a302f045941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the flow on the given arc.  <a href="#a7fc53c0667fdfb95dadd6a302f045941">More...</a><br/></td></tr>
<tr class="separator:a7fc53c0667fdfb95dadd6a302f045941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fb0010590a95a23fda72ce45474a2a"><td class="memTemplParams" colspan="2">template&lt;typename FlowMap &gt; </td></tr>
<tr class="memitem:ac7fb0010590a95a23fda72ce45474a2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#ac7fb0010590a95a23fda72ce45474a2a">flowMap</a> (FlowMap &amp;map) const </td></tr>
<tr class="memdesc:ac7fb0010590a95a23fda72ce45474a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the flow values (the primal solution) into the given map.  <a href="#ac7fb0010590a95a23fda72ce45474a2a">More...</a><br/></td></tr>
<tr class="separator:ac7fb0010590a95a23fda72ce45474a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97efaa2b500bb002f116bf4ba7c9b0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00276.html#adeb81a88e6bbaf933ca20ea3bbba7a2c">Cost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#ac97efaa2b500bb002f116bf4ba7c9b0b">potential</a> (const Node &amp;n) const </td></tr>
<tr class="memdesc:ac97efaa2b500bb002f116bf4ba7c9b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the potential (dual value) of the given node.  <a href="#ac97efaa2b500bb002f116bf4ba7c9b0b">More...</a><br/></td></tr>
<tr class="separator:ac97efaa2b500bb002f116bf4ba7c9b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeeff1d0249ffae4db8cc516b77d2cc9"><td class="memTemplParams" colspan="2">template&lt;typename PotentialMap &gt; </td></tr>
<tr class="memitem:afeeff1d0249ffae4db8cc516b77d2cc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00276.html#afeeff1d0249ffae4db8cc516b77d2cc9">potentialMap</a> (PotentialMap &amp;map) const </td></tr>
<tr class="memdesc:afeeff1d0249ffae4db8cc516b77d2cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the potential values (the dual solution) into the given map.  <a href="#afeeff1d0249ffae4db8cc516b77d2cc9">More...</a><br/></td></tr>
<tr class="separator:afeeff1d0249ffae4db8cc516b77d2cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a601ffd79f13610daacadd46f973507c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="a00276.html#a6c1768456283cc436140a9ffae849dd2">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00276.html#a601ffd79f13610daacadd46f973507c5">INF</a></td></tr>
<tr class="memdesc:a601ffd79f13610daacadd46f973507c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant for infinite upper bounds (capacities).  <a href="#a601ffd79f13610daacadd46f973507c5">More...</a><br/></td></tr>
<tr class="separator:a601ffd79f13610daacadd46f973507c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00276.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum type containing the problem type constants that can be returned by the <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> function of the algorithm. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea2884fa43446c0cbc9c7a9b74d41d7483"></a>INFEASIBLE</em>&nbsp;</td><td class="fielddoc">
<p>The problem has no feasible solution (flow). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea2579881e7c83261bc21bafb5a5c92cad"></a>OPTIMAL</em>&nbsp;</td><td class="fielddoc">
<p>The problem has optimal solution (i.e. it is feasible and bounded), and the algorithm has found optimal flow and node potentials (primal and dual solutions). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4c669cb1cb4d98dfea944e9ceec7d33ea6c65123d1b5b01632a477661055b01ef"></a>UNBOUNDED</em>&nbsp;</td><td class="fielddoc">
<p>The objective function of the problem is unbounded, i.e. there is a directed cycle having negative total cost and infinite upper bound. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac860a45e09c68fb71f723d392c3161ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00276.html#ac860a45e09c68fb71f723d392c3161ac">SupplyType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum type containing constants for selecting the supply type, i.e. the direction of the inequalities in the supply/demand constraints of the <a class="el" href="a00010.html">minimum cost flow problem</a>.</p>
<p>The default supply type is <code>GEQ</code>, the <code>LEQ</code> type can be selected using <a class="el" href="a00276.html#a40c06e412dc08e6a541abbcf97385b1e">supplyType()</a>. The equality form is a special case of both supply types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ac860a45e09c68fb71f723d392c3161aca99705e9593e3e5c078150b293c86561e"></a>GEQ</em>&nbsp;</td><td class="fielddoc">
<p>This option means that there are <em>"greater or equal"</em> supply/demand constraints in the definition of the problem. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ac860a45e09c68fb71f723d392c3161aca5eba1d52e68e10fb2dafcb363cec49b7"></a>LEQ</em>&nbsp;</td><td class="fielddoc">
<p>This option means that there are <em>"less or equal"</em> supply/demand constraints in the definition of the problem. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a310d3a1fcfff1e099330ae372abc73c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2">PivotRule</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum type containing constants for selecting the pivot rule for the <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> function.</p>
<p><a class="el" href="a00276.html">NetworkSimplex</a> provides five different implementations for the pivot strategy that significantly affects the running time of the algorithm. According to experimental tests conducted on various problem instances, <a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2afa32a0f9c82dc3e2e1000b6086d3fc1c">Block Search</a> and <a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2a76eceb36ac871a19d694999a965f877a">Altering Candidate List</a> rules turned out to be the most efficient. Since <a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2afa32a0f9c82dc3e2e1000b6086d3fc1c">Block Search</a> is a simpler strategy that seemed to be slightly more robust, it is used by default. However, another pivot rule can easily be selected using the <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> function with the proper parameter. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a310d3a1fcfff1e099330ae372abc73c2a7c31211b575a3beecd934538c4419b25"></a>FIRST_ELIGIBLE</em>&nbsp;</td><td class="fielddoc">
<p>The <em>First</em> <em>Eligible</em> pivot rule. The next eligible arc is selected in a wraparound fashion in every iteration. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a310d3a1fcfff1e099330ae372abc73c2ac89b3377964fb28026f9b814f30c210b"></a>BEST_ELIGIBLE</em>&nbsp;</td><td class="fielddoc">
<p>The <em>Best</em> <em>Eligible</em> pivot rule. The best eligible arc is selected in every iteration. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a310d3a1fcfff1e099330ae372abc73c2afa32a0f9c82dc3e2e1000b6086d3fc1c"></a>BLOCK_SEARCH</em>&nbsp;</td><td class="fielddoc">
<p>The <em>Block</em> <em>Search</em> pivot rule. A specified number of arcs are examined in every iteration in a wraparound fashion and the best eligible arc is selected from this block. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a310d3a1fcfff1e099330ae372abc73c2a8d608c7bc486d1c56c7e5a5a6c6a616d"></a>CANDIDATE_LIST</em>&nbsp;</td><td class="fielddoc">
<p>The <em>Candidate</em> <em>List</em> pivot rule. In a major iteration a candidate list is built from eligible arcs in a wraparound fashion and in the following minor iterations the best eligible arc is selected from this list. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a310d3a1fcfff1e099330ae372abc73c2a76eceb36ac871a19d694999a965f877a"></a>ALTERING_LIST</em>&nbsp;</td><td class="fielddoc">
<p>The <em>Altering</em> <em>Candidate</em> <em>List</em> pivot rule. It is a modified version of the Candidate List method. It keeps only a few of the best eligible arcs from the former candidate list and extends this list in every iteration. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aadcbd3709a402a8ba8d06b8c3d6504d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00276.html">NetworkSimplex</a> </td>
          <td>(</td>
          <td class="paramtype">const GR &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>arc_mixing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The constructor of the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>The digraph the algorithm runs on. </td></tr>
    <tr><td class="paramname">arc_mixing</td><td>Indicate if the arcs will be stored in a mixed order in the internal data structure. In general, it leads to similar performance as using the original arc order, but it makes the algorithm more robust and in special cases, even significantly faster. Therefore, it is enabled by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa0198dc86458cf5d9893eaac3875faff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00276.html">NetworkSimplex</a>&amp; lowerMap </td>
          <td>(</td>
          <td class="paramtype">const LowerMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the lower bounds on the arcs. If it is not used before calling <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>, the lower bounds will be set to zero on all arcs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>An arc map storing the lower bounds. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a3d130a8189e0bed5939be2876b1183f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00276.html">NetworkSimplex</a>&amp; upperMap </td>
          <td>(</td>
          <td class="paramtype">const UpperMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the upper bounds (capacities) on the arcs. If it is not used before calling <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>, the upper bounds will be set to <a class="el" href="a00276.html#a601ffd79f13610daacadd46f973507c5">INF</a> on all arcs (i.e. the flow value will be unbounded from above).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>An arc map storing the upper bounds. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="afa88624e168f246d882e8193fdf12f5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00276.html">NetworkSimplex</a>&amp; costMap </td>
          <td>(</td>
          <td class="paramtype">const CostMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the costs of the arcs. If it is not used before calling <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>, the costs will be set to <code>1</code> on all arcs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>An arc map storing the costs. Its <code>Value</code> type must be convertible to the <code>Cost</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a3856a08752190c4b99f5e006e3b14c53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00276.html">NetworkSimplex</a>&amp; supplyMap </td>
          <td>(</td>
          <td class="paramtype">const SupplyMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the supply values of the nodes. If neither this function nor <a class="el" href="a00276.html#ac622127c2be52342b9becb61ff28e56e">stSupply()</a> is used before calling <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>, the supply of each node will be set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A node map storing the supply values. Its <code>Value</code> type must be convertible to the <code>Value</code> type of the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00276.html#a40c06e412dc08e6a541abbcf97385b1e" title="Set the type of the supply constraints. ">supplyType()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac622127c2be52342b9becb61ff28e56e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00276.html">NetworkSimplex</a>&amp; stSupply </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Node &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00276.html#a6c1768456283cc436140a9ffae849dd2">Value</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets a single source node and a single target node and the required flow value. If neither this function nor <a class="el" href="a00276.html#a3856a08752190c4b99f5e006e3b14c53">supplyMap()</a> is used before calling <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>, the supply of each node will be set to zero.</p>
<p>Using this function has the same effect as using <a class="el" href="a00276.html#a3856a08752190c4b99f5e006e3b14c53">supplyMap()</a> with a map in which <code>k</code> is assigned to <code>s</code>, <code>-k</code> is assigned to <code>t</code> and all other nodes have zero supply value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The source node. </td></tr>
    <tr><td class="paramname">t</td><td>The target node. </td></tr>
    <tr><td class="paramname">k</td><td>The required amount of flow from node <code>s</code> to node <code>t</code> (i.e. the supply of <code>s</code> and the demand of <code>t</code>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a40c06e412dc08e6a541abbcf97385b1e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00276.html">NetworkSimplex</a>&amp; supplyType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00276.html#ac860a45e09c68fb71f723d392c3161ac">SupplyType</a>&#160;</td>
          <td class="paramname"><em>supply_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function sets the type of the supply/demand constraints. If it is not used before calling <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a>, the <a class="el" href="a00276.html#ac860a45e09c68fb71f723d392c3161aca99705e9593e3e5c078150b293c86561e">GEQ</a> supply type will be used.</p>
<p>For more information, see <a class="el" href="a00276.html#ac860a45e09c68fb71f723d392c3161ac">SupplyType</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a591276ea8f1afbe9d24bd1c1d48b0f53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00276.html#a4c669cb1cb4d98dfea944e9ceec7d33e">ProblemType</a> run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2">PivotRule</a>&#160;</td>
          <td class="paramname"><em>pivot_rule</em> = <code><a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2afa32a0f9c82dc3e2e1000b6086d3fc1c">BLOCK_SEARCH</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function runs the algorithm. The paramters can be specified using functions <a class="el" href="a00276.html#aa0198dc86458cf5d9893eaac3875faff">lowerMap()</a>, <a class="el" href="a00276.html#a3d130a8189e0bed5939be2876b1183f1">upperMap()</a>, <a class="el" href="a00276.html#afa88624e168f246d882e8193fdf12f5b">costMap()</a>, <a class="el" href="a00276.html#a3856a08752190c4b99f5e006e3b14c53">supplyMap()</a>, <a class="el" href="a00276.html#ac622127c2be52342b9becb61ff28e56e">stSupply()</a>, <a class="el" href="a00276.html#a40c06e412dc08e6a541abbcf97385b1e">supplyType()</a>. For example, </p>
<div class="fragment"><div class="line">*    NetworkSimplex&lt;ListDigraph&gt; ns(graph);</div>
<div class="line">*    ns.lowerMap(lower).upperMap(upper).costMap(cost)</div>
<div class="line">*      .supplyMap(sup).run();</div>
<div class="line">*  </div>
</div><!-- fragment --><p>This function can be called more than once. All the given parameters are kept for the next call, unless <a class="el" href="a00276.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams()</a> or <a class="el" href="a00276.html#a88086127469093e19a9a024bbf60c360">reset()</a> is used, thus only the modified parameters have to be set again. If the underlying digraph was also modified after the construction of the class (or the last <a class="el" href="a00276.html#a88086127469093e19a9a024bbf60c360">reset()</a> call), then the <a class="el" href="a00276.html#a88086127469093e19a9a024bbf60c360">reset()</a> function must be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pivot_rule</td><td>The pivot rule that will be used during the algorithm. For more information, see <a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2">PivotRule</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>INFEASIBLE</code> if no feasible flow exists, <br/>
 <code>OPTIMAL</code> if the problem has optimal solution (i.e. it is feasible and bounded), and the algorithm has found optimal flow and node potentials (primal and dual solutions), <br/>
 <code>UNBOUNDED</code> if the objective function of the problem is unbounded, i.e. there is a directed cycle having negative total cost and infinite upper bound.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00276.html#a4c669cb1cb4d98dfea944e9ceec7d33e" title="Problem type constants for the run() function. ">ProblemType</a>, <a class="el" href="a00276.html#a310d3a1fcfff1e099330ae372abc73c2" title="Constants for selecting the pivot rule. ">PivotRule</a> </dd>
<dd>
<a class="el" href="a00276.html#aefce8a05d41659d7aaffb4cb47eeec43" title="Reset all the parameters that have been given before. ">resetParams()</a>, <a class="el" href="a00276.html#a88086127469093e19a9a024bbf60c360" title="Reset the internal data structures and all the parameters that have been given before. ">reset()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aefce8a05d41659d7aaffb4cb47eeec43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00276.html">NetworkSimplex</a>&amp; resetParams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function resets all the paramaters that have been given before using functions <a class="el" href="a00276.html#aa0198dc86458cf5d9893eaac3875faff">lowerMap()</a>, <a class="el" href="a00276.html#a3d130a8189e0bed5939be2876b1183f1">upperMap()</a>, <a class="el" href="a00276.html#afa88624e168f246d882e8193fdf12f5b">costMap()</a>, <a class="el" href="a00276.html#a3856a08752190c4b99f5e006e3b14c53">supplyMap()</a>, <a class="el" href="a00276.html#ac622127c2be52342b9becb61ff28e56e">stSupply()</a>, <a class="el" href="a00276.html#a40c06e412dc08e6a541abbcf97385b1e">supplyType()</a>.</p>
<p>It is useful for multiple <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> calls. Basically, all the given parameters are kept for the next <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> call, unless <a class="el" href="a00276.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams()</a> or <a class="el" href="a00276.html#a88086127469093e19a9a024bbf60c360">reset()</a> is used. If the underlying digraph was also modified after the construction of the class or the last <a class="el" href="a00276.html#a88086127469093e19a9a024bbf60c360">reset()</a> call, then the <a class="el" href="a00276.html#a88086127469093e19a9a024bbf60c360">reset()</a> function must be used, otherwise <a class="el" href="a00276.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams()</a> is sufficient.</p>
<p>For example, </p>
<div class="fragment"><div class="line">*    NetworkSimplex&lt;ListDigraph&gt; ns(graph);</div>
<div class="line">* </div>
<div class="line">*    <span class="comment">// First run</span></div>
<div class="line">*    ns.lowerMap(lower).upperMap(upper).costMap(cost)</div>
<div class="line">*      .supplyMap(sup).run();</div>
<div class="line">* </div>
<div class="line">*    <span class="comment">// Run again with modified cost map (resetParams() is not called,</span></div>
<div class="line">*    <span class="comment">// so only the cost map have to be set again)</span></div>
<div class="line">*    cost[e] += 100;</div>
<div class="line">*    ns.costMap(cost).run();</div>
<div class="line">* </div>
<div class="line">*    <span class="comment">// Run again from scratch using resetParams()</span></div>
<div class="line">*    <span class="comment">// (the lower bounds will be set to zero on all arcs)</span></div>
<div class="line">*    ns.resetParams();</div>
<div class="line">*    ns.upperMap(capacity).costMap(cost)</div>
<div class="line">*      .supplyMap(sup).run();</div>
<div class="line">*  </div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd><code>(*this)</code></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00276.html#a88086127469093e19a9a024bbf60c360" title="Reset the internal data structures and all the parameters that have been given before. ">reset()</a>, <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53" title="Run the algorithm. ">run()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a88086127469093e19a9a024bbf60c360"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00276.html">NetworkSimplex</a>&amp; reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function resets the internal data structures and all the paramaters that have been given before using functions <a class="el" href="a00276.html#aa0198dc86458cf5d9893eaac3875faff">lowerMap()</a>, <a class="el" href="a00276.html#a3d130a8189e0bed5939be2876b1183f1">upperMap()</a>, <a class="el" href="a00276.html#afa88624e168f246d882e8193fdf12f5b">costMap()</a>, <a class="el" href="a00276.html#a3856a08752190c4b99f5e006e3b14c53">supplyMap()</a>, <a class="el" href="a00276.html#ac622127c2be52342b9becb61ff28e56e">stSupply()</a>, <a class="el" href="a00276.html#a40c06e412dc08e6a541abbcf97385b1e">supplyType()</a>.</p>
<p>It is useful for multiple <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> calls. Basically, all the given parameters are kept for the next <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> call, unless <a class="el" href="a00276.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams()</a> or <a class="el" href="a00276.html#a88086127469093e19a9a024bbf60c360">reset()</a> is used. If the underlying digraph was also modified after the construction of the class or the last <a class="el" href="a00276.html#a88086127469093e19a9a024bbf60c360">reset()</a> call, then the <a class="el" href="a00276.html#a88086127469093e19a9a024bbf60c360">reset()</a> function must be used, otherwise <a class="el" href="a00276.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams()</a> is sufficient.</p>
<p>See <a class="el" href="a00276.html#aefce8a05d41659d7aaffb4cb47eeec43">resetParams()</a> for examples.</p>
<dl class="section return"><dt>Returns</dt><dd><code>(*this)</code></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="a00276.html#aefce8a05d41659d7aaffb4cb47eeec43" title="Reset all the parameters that have been given before. ">resetParams()</a>, <a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53" title="Run the algorithm. ">run()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4e1efd04a6b234645d1ca18d2635d57e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number totalCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the total cost of the found flow. Its complexity is O(m).</p>
<dl class="section note"><dt>Note</dt><dd>The return type of the function can be specified as a template parameter. For example, <div class="fragment"><div class="line">*    ns.totalCost&lt;<span class="keywordtype">double</span>&gt;();</div>
<div class="line">*  </div>
</div><!-- fragment --> It is useful if the total cost cannot be stored in the <code>Cost</code> type of the algorithm, which is the default return type of the function.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fc53c0667fdfb95dadd6a302f045941"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00276.html#a6c1768456283cc436140a9ffae849dd2">Value</a> flow </td>
          <td>(</td>
          <td class="paramtype">const Arc &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the flow on the given arc.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7fb0010590a95a23fda72ce45474a2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void flowMap </td>
          <td>(</td>
          <td class="paramtype">FlowMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies the flow value on each arc into the given map. The <code>Value</code> type of the algorithm must be convertible to the <code>Value</code> type of the map.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ac97efaa2b500bb002f116bf4ba7c9b0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00276.html#adeb81a88e6bbaf933ca20ea3bbba7a2c">Cost</a> potential </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the potential (dual value) of the given node.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<a class="anchor" id="afeeff1d0249ffae4db8cc516b77d2cc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void potentialMap </td>
          <td>(</td>
          <td class="paramtype">PotentialMap &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies the potential (dual value) of each node into the given map. The <code>Cost</code> type of the algorithm must be convertible to the <code>Value</code> type of the map.</p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00276.html#a591276ea8f1afbe9d24bd1c1d48b0f53">run()</a> must be called before using this function. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a601ffd79f13610daacadd46f973507c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="a00276.html#a6c1768456283cc436140a9ffae849dd2">Value</a> INF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constant for infinite upper bounds (capacities). It is <code>std::numeric_limits&lt;Value&gt;::infinity()</code> if available, <code>std::numeric_limits&lt;Value&gt;::max()</code> otherwise. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 7 2014 16:39:55 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
