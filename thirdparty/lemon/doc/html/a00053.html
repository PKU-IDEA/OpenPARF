<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>BfsVisit&lt; GR, VS, TR &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00573.html">lemon</a></li><li class="navelem"><a class="el" href="a00053.html">BfsVisit</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="a00693.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">BfsVisit&lt; GR, VS, TR &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00608.html">Graph Search</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename GR, typename VS, typename TR&gt;<br/>
class lemon::BfsVisit&lt; GR, VS, TR &gt;</h3>

<p>This class provides an efficient implementation of the BFS algorithm with visitor interface.</p>
<p>The <a class="el" href="a00053.html" title="BFS algorithm class with visitor interface. ">BfsVisit</a> class provides an alternative interface to the <a class="el" href="a00051.html" title="BFS algorithm class. ">Bfs</a> class. It works with callback mechanism, the <a class="el" href="a00053.html" title="BFS algorithm class with visitor interface. ">BfsVisit</a> object calls the member functions of the <code>Visitor</code> class on every BFS event.</p>
<p>This interface of the BFS algorithm should be used in special cases when extra actions have to be performed in connection with certain events of the BFS algorithm. Otherwise consider to use <a class="el" href="a00051.html" title="BFS algorithm class. ">Bfs</a> or <a class="el" href="a00608.html#ga99817221896aba2eb403691a0a230a0b" title="Function-type interface for BFS algorithm. ">bfs()</a> instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">GR</td><td>The type of the digraph the algorithm runs on. The default type is <a class="el" href="a00242.html">ListDigraph</a>. The value of GR is not used directly by <a class="el" href="a00053.html">BfsVisit</a>, it is only passed to <a class="el" href="a00054.html">BfsVisitDefaultTraits</a>. </td></tr>
    <tr><td class="paramname">VS</td><td>The Visitor type that is used by the algorithm. <a class="el" href="a00055.html">BfsVisitor&lt;GR&gt;</a> is an empty visitor, which does not observe the BFS events. If you want to observe the BFS events, you should implement your own visitor class. </td></tr>
    <tr><td class="paramname">TR</td><td>The traits class that defines various types used by the algorithm. By default, it is <a class="el" href="a00054.html">BfsVisitDefaultTraits&lt;GR&gt;</a>. In most cases, this parameter should not be set directly, consider to use the named template parameters instead. </td></tr>
  </table>
  </dd>
</dl>
</div>
<p><code>#include &lt;lemon/bfs.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00381.html">SetReachedMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00012.html#named-templ-param">Named parameter</a> for setting ReachedMap type.  <a href="a00381.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab157e5452122f7a7f73dfda5ed931d69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab157e5452122f7a7f73dfda5ed931d69"></a>
typedef TR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#ab157e5452122f7a7f73dfda5ed931d69">Traits</a></td></tr>
<tr class="memdesc:ab157e5452122f7a7f73dfda5ed931d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">The traits class. <br/></td></tr>
<tr class="separator:ab157e5452122f7a7f73dfda5ed931d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6928feef02be4f2a184775d19dc6373"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6928feef02be4f2a184775d19dc6373"></a>
typedef Traits::Digraph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#aa6928feef02be4f2a184775d19dc6373">Digraph</a></td></tr>
<tr class="memdesc:aa6928feef02be4f2a184775d19dc6373"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the digraph the algorithm runs on. <br/></td></tr>
<tr class="separator:aa6928feef02be4f2a184775d19dc6373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bece3b7c0b0189b735a408e533f3d73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bece3b7c0b0189b735a408e533f3d73"></a>
typedef VS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a3bece3b7c0b0189b735a408e533f3d73">Visitor</a></td></tr>
<tr class="memdesc:a3bece3b7c0b0189b735a408e533f3d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">The visitor type used by the algorithm. <br/></td></tr>
<tr class="separator:a3bece3b7c0b0189b735a408e533f3d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90221be1b9274785db2188548354d2aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90221be1b9274785db2188548354d2aa"></a>
typedef Traits::ReachedMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a90221be1b9274785db2188548354d2aa">ReachedMap</a></td></tr>
<tr class="memdesc:a90221be1b9274785db2188548354d2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the map that indicates which nodes are reached. <br/></td></tr>
<tr class="separator:a90221be1b9274785db2188548354d2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae27c446704010b785a05379a1e02811e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#ae27c446704010b785a05379a1e02811e">BfsVisit</a> (const <a class="el" href="a00053.html#aa6928feef02be4f2a184775d19dc6373">Digraph</a> &amp;digraph, <a class="el" href="a00053.html#a3bece3b7c0b0189b735a408e533f3d73">Visitor</a> &amp;visitor)</td></tr>
<tr class="memdesc:ae27c446704010b785a05379a1e02811e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ae27c446704010b785a05379a1e02811e">More...</a><br/></td></tr>
<tr class="separator:ae27c446704010b785a05379a1e02811e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf7b105577e2894778cc63cbec43a24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bf7b105577e2894778cc63cbec43a24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a8bf7b105577e2894778cc63cbec43a24">~BfsVisit</a> ()</td></tr>
<tr class="memdesc:a8bf7b105577e2894778cc63cbec43a24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a8bf7b105577e2894778cc63cbec43a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51540af2212fa8760166385adbaa9f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00053.html">BfsVisit</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a51540af2212fa8760166385adbaa9f34">reachedMap</a> (<a class="el" href="a00053.html#a90221be1b9274785db2188548354d2aa">ReachedMap</a> &amp;m)</td></tr>
<tr class="memdesc:a51540af2212fa8760166385adbaa9f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the map that indicates which nodes are reached.  <a href="#a51540af2212fa8760166385adbaa9f34">More...</a><br/></td></tr>
<tr class="separator:a51540af2212fa8760166385adbaa9f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Execution Control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The simplest way to execute the BFS algorithm is to use one of the member functions called <a class="el" href="a00053.html#ae3f0682c90a4e8a23c259943e899402e">run()</a>.<br/>
If you need better control on the execution, you have to call <a class="el" href="a00053.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> first, then you can add several source nodes with <a class="el" href="a00053.html#ac785b6504b67a963b4c20bae90441a77">addSource()</a>. Finally the actual path computation can be performed with one of the <a class="el" href="a00053.html#a60de64d75454385b23995437f1d72669">start()</a> functions. </p>
</div></td></tr>
<tr class="memitem:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a02fd73d861ef2e4aabb38c0c9ff82947">init</a> ()</td></tr>
<tr class="memdesc:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the internal data structures.  <a href="#a02fd73d861ef2e4aabb38c0c9ff82947">More...</a><br/></td></tr>
<tr class="separator:a02fd73d861ef2e4aabb38c0c9ff82947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac785b6504b67a963b4c20bae90441a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#ac785b6504b67a963b4c20bae90441a77">addSource</a> (Node s)</td></tr>
<tr class="memdesc:ac785b6504b67a963b4c20bae90441a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new source node.  <a href="#ac785b6504b67a963b4c20bae90441a77">More...</a><br/></td></tr>
<tr class="separator:ac785b6504b67a963b4c20bae90441a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba758047d7378b8a06320d29ce170d7"><td class="memItemLeft" align="right" valign="top">Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#adba758047d7378b8a06320d29ce170d7">processNextNode</a> ()</td></tr>
<tr class="memdesc:adba758047d7378b8a06320d29ce170d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes the next node.  <a href="#adba758047d7378b8a06320d29ce170d7">More...</a><br/></td></tr>
<tr class="separator:adba758047d7378b8a06320d29ce170d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f85441d2cf615f40794ac052db5cb18"><td class="memItemLeft" align="right" valign="top">Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a8f85441d2cf615f40794ac052db5cb18">processNextNode</a> (Node target, bool &amp;reach)</td></tr>
<tr class="memdesc:a8f85441d2cf615f40794ac052db5cb18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes the next node.  <a href="#a8f85441d2cf615f40794ac052db5cb18">More...</a><br/></td></tr>
<tr class="separator:a8f85441d2cf615f40794ac052db5cb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1f6562157e06f1807253d8e8fa08c2"><td class="memTemplParams" colspan="2">template&lt;typename NM &gt; </td></tr>
<tr class="memitem:aaa1f6562157e06f1807253d8e8fa08c2"><td class="memTemplItemLeft" align="right" valign="top">Node&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00053.html#aaa1f6562157e06f1807253d8e8fa08c2">processNextNode</a> (const NM &amp;nm, Node &amp;rnode)</td></tr>
<tr class="memdesc:aaa1f6562157e06f1807253d8e8fa08c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Processes the next node.  <a href="#aaa1f6562157e06f1807253d8e8fa08c2">More...</a><br/></td></tr>
<tr class="separator:aaa1f6562157e06f1807253d8e8fa08c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca98e3b1fef1a4508df143a24b73b046"><td class="memItemLeft" align="right" valign="top">Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#aca98e3b1fef1a4508df143a24b73b046">nextNode</a> () const </td></tr>
<tr class="memdesc:aca98e3b1fef1a4508df143a24b73b046"><td class="mdescLeft">&#160;</td><td class="mdescRight">The next node to be processed.  <a href="#aca98e3b1fef1a4508df143a24b73b046">More...</a><br/></td></tr>
<tr class="separator:aca98e3b1fef1a4508df143a24b73b046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dcd2be02feaff0a95c21824e805445"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#ab6dcd2be02feaff0a95c21824e805445">emptyQueue</a> () const </td></tr>
<tr class="memdesc:ab6dcd2be02feaff0a95c21824e805445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>false</code> if there are nodes to be processed.  <a href="#ab6dcd2be02feaff0a95c21824e805445">More...</a><br/></td></tr>
<tr class="separator:ab6dcd2be02feaff0a95c21824e805445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942d30059e28f60ba6dd1944ab8e416e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a942d30059e28f60ba6dd1944ab8e416e">queueSize</a> () const </td></tr>
<tr class="memdesc:a942d30059e28f60ba6dd1944ab8e416e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the nodes to be processed.  <a href="#a942d30059e28f60ba6dd1944ab8e416e">More...</a><br/></td></tr>
<tr class="separator:a942d30059e28f60ba6dd1944ab8e416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60de64d75454385b23995437f1d72669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a60de64d75454385b23995437f1d72669">start</a> ()</td></tr>
<tr class="memdesc:a60de64d75454385b23995437f1d72669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the algorithm.  <a href="#a60de64d75454385b23995437f1d72669">More...</a><br/></td></tr>
<tr class="separator:a60de64d75454385b23995437f1d72669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b8de9dfc16e4b3cb6b38733e82f6449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a8b8de9dfc16e4b3cb6b38733e82f6449">start</a> (Node t)</td></tr>
<tr class="memdesc:a8b8de9dfc16e4b3cb6b38733e82f6449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the algorithm until the given target node is reached.  <a href="#a8b8de9dfc16e4b3cb6b38733e82f6449">More...</a><br/></td></tr>
<tr class="separator:a8b8de9dfc16e4b3cb6b38733e82f6449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d45ba85d8c33207fa0654c17ab2006"><td class="memTemplParams" colspan="2">template&lt;typename NM &gt; </td></tr>
<tr class="memitem:a88d45ba85d8c33207fa0654c17ab2006"><td class="memTemplItemLeft" align="right" valign="top">Node&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00053.html#a88d45ba85d8c33207fa0654c17ab2006">start</a> (const NM &amp;nm)</td></tr>
<tr class="memdesc:a88d45ba85d8c33207fa0654c17ab2006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the algorithm until a condition is met.  <a href="#a88d45ba85d8c33207fa0654c17ab2006">More...</a><br/></td></tr>
<tr class="separator:a88d45ba85d8c33207fa0654c17ab2006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f0682c90a4e8a23c259943e899402e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#ae3f0682c90a4e8a23c259943e899402e">run</a> (Node s)</td></tr>
<tr class="memdesc:ae3f0682c90a4e8a23c259943e899402e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the algorithm from the given source node.  <a href="#ae3f0682c90a4e8a23c259943e899402e">More...</a><br/></td></tr>
<tr class="separator:ae3f0682c90a4e8a23c259943e899402e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c3c4217c98b58a8618397d65d400c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#ad2c3c4217c98b58a8618397d65d400c8">run</a> (Node s, Node t)</td></tr>
<tr class="memdesc:ad2c3c4217c98b58a8618397d65d400c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the shortest path between <code>s</code> and <code>t</code>.  <a href="#ad2c3c4217c98b58a8618397d65d400c8">More...</a><br/></td></tr>
<tr class="separator:ad2c3c4217c98b58a8618397d65d400c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a43e6d814de94978c515cb084873b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#a13a43e6d814de94978c515cb084873b1">run</a> ()</td></tr>
<tr class="memdesc:a13a43e6d814de94978c515cb084873b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the algorithm to visit all nodes in the digraph.  <a href="#a13a43e6d814de94978c515cb084873b1">More...</a><br/></td></tr>
<tr class="separator:a13a43e6d814de94978c515cb084873b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The results of the BFS algorithm can be obtained using these functions.<br/>
Either <a class="el" href="a00053.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00053.html#a60de64d75454385b23995437f1d72669">start()</a> should be called before using them. </p>
</div></td></tr>
<tr class="memitem:abb98c427556a2afe917e41fe8d3e75bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html#abb98c427556a2afe917e41fe8d3e75bf">reached</a> (Node v) const </td></tr>
<tr class="memdesc:abb98c427556a2afe917e41fe8d3e75bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given node is reached from the root(s).  <a href="#abb98c427556a2afe917e41fe8d3e75bf">More...</a><br/></td></tr>
<tr class="separator:abb98c427556a2afe917e41fe8d3e75bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae27c446704010b785a05379a1e02811e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00053.html">BfsVisit</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00053.html#aa6928feef02be4f2a184775d19dc6373">Digraph</a> &amp;&#160;</td>
          <td class="paramname"><em>digraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00053.html#a3bece3b7c0b0189b735a408e533f3d73">Visitor</a> &amp;&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">digraph</td><td>The digraph the algorithm runs on. </td></tr>
    <tr><td class="paramname">visitor</td><td>The visitor object of the algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a51540af2212fa8760166385adbaa9f34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00053.html">BfsVisit</a>&amp; reachedMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00053.html#a90221be1b9274785db2188548354d2aa">ReachedMap</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the map that indicates which nodes are reached. If you don't use this function before calling <a class="el" href="a00053.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00053.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a>, an instance will be allocated automatically. The destructor deallocates this automatically allocated map, of course. </p>
<dl class="section return"><dt>Returns</dt><dd><code> (*this) </code> </dd></dl>

</div>
</div>
<a class="anchor" id="a02fd73d861ef2e4aabb38c0c9ff82947"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the internal data structures. </p>

</div>
</div>
<a class="anchor" id="ac785b6504b67a963b4c20bae90441a77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addSource </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a new source node to the set of nodes to be processed. </p>

</div>
</div>
<a class="anchor" id="adba758047d7378b8a06320d29ce170d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node processNextNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Processes the next node.</p>
<dl class="section return"><dt>Returns</dt><dd>The processed node.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The queue must not be empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f85441d2cf615f40794ac052db5cb18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node processNextNode </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>reach</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Processes the next node and checks if the given target node is reached. If the target node is reachable from the processed node, then the <code>reach</code> parameter will be set to <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">reach</td><td>Indicates if the target node is reached. It should be initially <code>false</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The processed node.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The queue must not be empty. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa1f6562157e06f1807253d8e8fa08c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node processNextNode </td>
          <td>(</td>
          <td class="paramtype">const NM &amp;&#160;</td>
          <td class="paramname"><em>nm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Node &amp;&#160;</td>
          <td class="paramname"><em>rnode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Processes the next node and checks if at least one of reached nodes has <code>true</code> value in the <code>nm</code> node map. If one node with <code>true</code> value is reachable from the processed node, then the <code>rnode</code> parameter will be set to the first of such nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>A <code>bool</code> (or convertible) node map that indicates the possible targets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">rnode</td><td>The reached target node. It should be initially <code>INVALID</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The processed node.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The queue must not be empty. </dd></dl>

</div>
</div>
<a class="anchor" id="aca98e3b1fef1a4508df143a24b73b046"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node nextNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the next node to be processed or <code>INVALID</code> if the queue is empty. </p>

</div>
</div>
<a class="anchor" id="ab6dcd2be02feaff0a95c21824e805445"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool emptyQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>false</code> if there are nodes to be processed in the queue. </p>

</div>
</div>
<a class="anchor" id="a942d30059e28f60ba6dd1944ab8e416e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int queueSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of the nodes to be processed in the queue. </p>

</div>
</div>
<a class="anchor" id="a60de64d75454385b23995437f1d72669"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes the algorithm.</p>
<p>This method runs the BFS algorithm from the root node(s) in order to compute the shortest path to each node.</p>
<p>The algorithm computes</p>
<ul>
<li>the shortest path tree (forest),</li>
<li>the distance of each node from the root(s).</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00053.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="Initializes the internal data structures. ">init()</a> must be called and at least one root node should be added with <a class="el" href="a00053.html#ac785b6504b67a963b4c20bae90441a77" title="Adds a new source node. ">addSource()</a> before using this function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>b.start()</code> is just a shortcut of the following code. <div class="fragment"><div class="line">*    <span class="keywordflow">while</span> ( !b.emptyQueue() ) {</div>
<div class="line">*      b.processNextNode();</div>
<div class="line">*    }</div>
<div class="line">*  </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b8de9dfc16e4b3cb6b38733e82f6449"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void start </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes the algorithm until the given target node is reached.</p>
<p>This method runs the BFS algorithm from the root node(s) in order to compute the shortest path to <code>t</code>.</p>
<p>The algorithm computes</p>
<ul>
<li>the shortest path to <code>t</code>,</li>
<li>the distance of <code>t</code> from the root(s).</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00053.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="Initializes the internal data structures. ">init()</a> must be called and at least one root node should be added with <a class="el" href="a00053.html#ac785b6504b67a963b4c20bae90441a77" title="Adds a new source node. ">addSource()</a> before using this function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>b.start(t)</code> is just a shortcut of the following code. <div class="fragment"><div class="line">*    <span class="keywordtype">bool</span> reach = <span class="keyword">false</span>;</div>
<div class="line">*    <span class="keywordflow">while</span> ( !b.emptyQueue() &amp;&amp; !reach ) {</div>
<div class="line">*      b.processNextNode(t, reach);</div>
<div class="line">*    }</div>
<div class="line">*  </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a88d45ba85d8c33207fa0654c17ab2006"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Node start </td>
          <td>(</td>
          <td class="paramtype">const NM &amp;&#160;</td>
          <td class="paramname"><em>nm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes the algorithm until a condition is met.</p>
<p>This method runs the BFS algorithm from the root node(s) in order to compute the shortest path to a node <code>v</code> with <code>nm[v]</code> true, if such a node can be found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nm</td><td>must be a bool (or convertible) node map. The algorithm will stop when it reaches a node <code>v</code> with <code>nm[v]</code> true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reached node <code>v</code> with <code>nm[v]</code> true or <code>INVALID</code> if no such node was found.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="a00053.html#a02fd73d861ef2e4aabb38c0c9ff82947" title="Initializes the internal data structures. ">init()</a> must be called and at least one root node should be added with <a class="el" href="a00053.html#ac785b6504b67a963b4c20bae90441a77" title="Adds a new source node. ">addSource()</a> before using this function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><code>b.start(nm)</code> is just a shortcut of the following code. <div class="fragment"><div class="line">*    Node rnode = <a class="code" href="a00573.html#a0f04de8e6be7bc21ed685c651571d9fe">INVALID</a>;</div>
<div class="line">*    <span class="keywordflow">while</span> ( !b.emptyQueue() &amp;&amp; rnode == <a class="code" href="a00573.html#a0f04de8e6be7bc21ed685c651571d9fe">INVALID</a> ) {</div>
<div class="line">*      b.processNextNode(nm, rnode);</div>
<div class="line">*    }</div>
<div class="line">*    <span class="keywordflow">return</span> rnode;</div>
<div class="line">*  </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ae3f0682c90a4e8a23c259943e899402e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method runs the BFS algorithm from node <code>s</code> in order to compute the shortest path to each node.</p>
<p>The algorithm computes</p>
<ul>
<li>the shortest path tree,</li>
<li>the distance of each node from the root.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><code>b.run(s)</code> is just a shortcut of the following code. <div class="fragment"><div class="line">*    b.init();</div>
<div class="line">*    b.addSource(s);</div>
<div class="line">*    b.start();</div>
<div class="line">* </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ad2c3c4217c98b58a8618397d65d400c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool run </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method runs the BFS algorithm from node <code>s</code> in order to compute the shortest path to node <code>t</code> (it stops searching when <code>t</code> is processed).</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <code>t</code> is reachable form <code>s</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Apart from the return value, <code>b.run(s,t)</code> is just a shortcut of the following code. <div class="fragment"><div class="line">*    b.init();</div>
<div class="line">*    b.addSource(s);</div>
<div class="line">*    b.start(t);</div>
<div class="line">* </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a13a43e6d814de94978c515cb084873b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method runs the BFS algorithm in order to visit all nodes in the digraph.</p>
<dl class="section note"><dt>Note</dt><dd><code>b.run(s)</code> is just a shortcut of the following code. <div class="fragment"><div class="line">*   b.init();</div>
<div class="line">*   <span class="keywordflow">for</span> (NodeIt n(gr); n != <a class="code" href="a00573.html#a0f04de8e6be7bc21ed685c651571d9fe">INVALID</a>; ++n) {</div>
<div class="line">*     <span class="keywordflow">if</span> (!b.reached(n)) {</div>
<div class="line">*       b.addSource(n);</div>
<div class="line">*       b.start();</div>
<div class="line">*     }</div>
<div class="line">*   }</div>
<div class="line">* </div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="abb98c427556a2afe917e41fe8d3e75bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool reached </td>
          <td>(</td>
          <td class="paramtype">Node&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if <code>v</code> is reached from the root(s).</p>
<dl class="section pre"><dt>Precondition</dt><dd>Either <a class="el" href="a00053.html#ae3f0682c90a4e8a23c259943e899402e">run()</a> or <a class="el" href="a00053.html#a02fd73d861ef2e4aabb38c0c9ff82947">init()</a> must be called before using this function. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 7 2014 16:39:52 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
